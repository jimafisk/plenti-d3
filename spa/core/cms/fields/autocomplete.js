/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	children,
	claim_element,
	claim_space,
	claim_text,
	destroy_each,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	select_option,
	select_value,
	set_data,
	set_input_value,
	space,
	svg_element,
	text
} from '../../../web_modules/svelte/internal/index.mjs';

import allContent from '../../../generated/content.js';

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i];
	return child_ctx;
}

// (53:8) {#if field.constructor === [].constructor}
function create_if_block_2(ctx) {
	let div;
	let each_value_1 = /*field*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "tags svelte-1tefo3y");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty & /*removeTag, field*/ 129) {
				each_value_1 = /*field*/ ctx[0];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (55:16) {#each field as tag}
function create_each_block_1(ctx) {
	let span;
	let t0_value = /*tag*/ ctx[17] + "";
	let t0;
	let t1;
	let svg;
	let path;
	let line0;
	let line1;
	let t2;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[10](/*tag*/ ctx[17]);
	}

	return {
		c() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			t2 = space();
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			t1 = claim_space(span_nodes);

			svg = claim_element(
				span_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path).forEach(detach);
			line0 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach);
			line1 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach);
			svg_nodes.forEach(detach);
			t2 = claim_space(span_nodes);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path, "stroke", "none");
			attr(path, "d", "M0 0h24v24H0z");
			attr(path, "fill", "none");
			attr(line0, "x1", "18");
			attr(line0, "y1", "6");
			attr(line0, "x2", "6");
			attr(line0, "y2", "18");
			attr(line1, "x1", "6");
			attr(line1, "y1", "6");
			attr(line1, "x2", "18");
			attr(line1, "y2", "18");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-x svelte-1tefo3y");
			attr(svg, "width", "15");
			attr(svg, "height", "15");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke", "#2c3e50");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(span, "class", "tag svelte-1tefo3y");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			append(span, svg);
			append(svg, path);
			append(svg, line0);
			append(svg, line1);
			append(span, t2);

			if (!mounted) {
				dispose = listen(svg, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*field*/ 1 && t0_value !== (t0_value = /*tag*/ ctx[17] + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

// (75:8) {:else}
function create_else_block(ctx) {
	let svg;
	let path;
	let circle;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			this.h();
		},
		l(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path).forEach(detach);
			circle = claim_element(svg_nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle).forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path, "stroke", "none");
			attr(path, "d", "M0 0h24v24H0z");
			attr(path, "fill", "none");
			attr(circle, "cx", "12");
			attr(circle, "cy", "12");
			attr(circle, "r", "9");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-circle");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke", "gray");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, circle);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (70:8) {#if loading}
function create_if_block_1(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M12 3a9 9 0 1 0 9 9");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-loader-2 svelte-1tefo3y");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke", "gray");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (82:4) {#if results && results.length > 0}
function create_if_block(ctx) {
	let select;
	let select_size_value;
	let mounted;
	let dispose;
	let each_value = /*results*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			select = claim_element(nodes, "SELECT", { size: true, class: true });
			var select_nodes = children(select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(select_nodes);
			}

			select_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(select, "size", select_size_value = /*results*/ ctx[2].length === 1
			? 2
			: /*results*/ ctx[2].length);

			attr(select, "class", "svelte-1tefo3y");
			if (/*option*/ ctx[4] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[12].call(select));
		},
		m(target, anchor) {
			insert(target, select, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*option*/ ctx[4]);

			if (!mounted) {
				dispose = listen(select, "change", /*select_change_handler*/ ctx[12]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*results, makeSelection*/ 68) {
				each_value = /*results*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*results*/ 4 && select_size_value !== (select_size_value = /*results*/ ctx[2].length === 1
			? 2
			: /*results*/ ctx[2].length)) {
				attr(select, "size", select_size_value);
			}

			if (dirty & /*option, results*/ 20) {
				select_option(select, /*option*/ ctx[4]);
			}
		},
		d(detaching) {
			if (detaching) detach(select);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};
}

// (84:12) {#each results as result}
function create_each_block(ctx) {
	let option_1;
	let t_value = /*result*/ ctx[14] + "";
	let t;
	let option_1_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			option_1 = element("option");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			option_1 = claim_element(nodes, "OPTION", { class: true });
			var option_1_nodes = children(option_1);
			t = claim_text(option_1_nodes, t_value);
			option_1_nodes.forEach(detach);
			this.h();
		},
		h() {
			option_1.__value = option_1_value_value = /*result*/ ctx[14];
			option_1.value = option_1.__value;
			attr(option_1, "class", "svelte-1tefo3y");
		},
		m(target, anchor) {
			insert(target, option_1, anchor);
			append(option_1, t);

			if (!mounted) {
				dispose = listen(option_1, "click", /*makeSelection*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*results*/ 4 && t_value !== (t_value = /*result*/ ctx[14] + "")) set_data(t, t_value);

			if (dirty & /*results*/ 4 && option_1_value_value !== (option_1_value_value = /*result*/ ctx[14])) {
				option_1.__value = option_1_value_value;
				option_1.value = option_1.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option_1);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let div2;
	let div0;
	let t0;
	let input_1;
	let t1;
	let div1;
	let t2;
	let mounted;
	let dispose;
	let if_block0 = /*field*/ ctx[0].constructor === [].constructor && create_if_block_2(ctx);

	function select_block_type(ctx, dirty) {
		if (/*loading*/ ctx[3]) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block1 = current_block_type(ctx);
	let if_block2 = /*results*/ ctx[2] && /*results*/ ctx[2].length > 0 && create_if_block(ctx);

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			input_1 = element("input");
			t1 = space();
			div1 = element("div");
			if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (if_block0) if_block0.l(div0_nodes);
			t0 = claim_space(div0_nodes);
			input_1 = claim_element(div0_nodes, "INPUT", { class: true });
			div0_nodes.forEach(detach);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if_block1.l(div1_nodes);
			div1_nodes.forEach(detach);
			t2 = claim_space(div2_nodes);
			if (if_block2) if_block2.l(div2_nodes);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(input_1, "class", "svelte-1tefo3y");
			attr(div0, "class", "input-wrapper svelte-1tefo3y");
			attr(div1, "class", "load-icon svelte-1tefo3y");
			attr(div2, "class", "autocomplete svelte-1tefo3y");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			if (if_block0) if_block0.m(div0, null);
			append(div0, t0);
			append(div0, input_1);
			set_input_value(input_1, /*input*/ ctx[1]);
			append(div2, t1);
			append(div2, div1);
			if_block1.m(div1, null);
			append(div2, t2);
			if (if_block2) if_block2.m(div2, null);

			if (!mounted) {
				dispose = [
					listen(input_1, "input", /*input_1_input_handler*/ ctx[11]),
					listen(input_1, "keyup", /*search*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*field*/ ctx[0].constructor === [].constructor) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div0, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*input*/ 2 && input_1.value !== /*input*/ ctx[1]) {
				set_input_value(input_1, /*input*/ ctx[1]);
			}

			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div1, null);
				}
			}

			if (/*results*/ ctx[2] && /*results*/ ctx[2].length > 0) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					if_block2.m(div2, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			if (if_block0) if_block0.d();
			if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { schema } = $$props, { parentKeys } = $$props, { field } = $$props;
	let input, results, loading, option;
	let deepCloneContent = structuredClone(allContent);

	// Make sure field value starts as an array
	if (field.constructor !== [].constructor) {
		field = [field];
	}

	const search = () => {
		$$invalidate(3, loading = true);
		$$invalidate(2, results = []);

		schema[parentKeys].options.forEach(option => {
			let filteredContent = deepCloneContent.filter(c => c.type === option.type);

			filteredContent.forEach(content => {
				option.search.forEach(field => {
					if (content.fields.hasOwnProperty(field) && content.fields[field].includes(input)) {
						let parts = option.result.split(".");
						let newResult = content[parts[0]];

						if (parts.length > 1) {
							parts.slice(1).forEach(part => {
								newResult = newResult[part];
							});
						}

						$$invalidate(2, results = [...results, newResult]);
					}
				});
			});
		});

		if (input === "") {
			$$invalidate(2, results = []);
		}

		setTimeout(
			() => {
				$$invalidate(3, loading = false);
			},
			"500"
		);
	};

	const makeSelection = () => {
		$$invalidate(2, results = []);
		$$invalidate(0, field = [...field, option]);
		$$invalidate(1, input = "");
	};

	const removeTag = tag => {
		$$invalidate(0, field = field.filter(t => t !== tag));
	};

	const click_handler = tag => removeTag(tag);

	function input_1_input_handler() {
		input = this.value;
		$$invalidate(1, input);
	}

	function select_change_handler() {
		option = select_value(this);
		$$invalidate(4, option);
		$$invalidate(2, results);
	}

	$$self.$$set = $$props => {
		if ("schema" in $$props) $$invalidate(8, schema = $$props.schema);
		if ("parentKeys" in $$props) $$invalidate(9, parentKeys = $$props.parentKeys);
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
	};

	return [
		field,
		input,
		results,
		loading,
		option,
		search,
		makeSelection,
		removeTag,
		schema,
		parentKeys,
		click_handler,
		input_1_input_handler,
		select_change_handler
	];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { schema: 8, parentKeys: 9, field: 0 });
	}
}

export default Component;