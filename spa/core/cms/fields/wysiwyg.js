/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	binding_callbacks,
	children,
	claim_element,
	claim_space,
	claim_text,
	detach,
	element,
	init,
	insert,
	is_function,
	listen,
	noop,
	prevent_default,
	run_all,
	safe_not_equal,
	space,
	svg_element,
	text
} from '../../../web_modules/svelte/internal/index.mjs';

function create_if_block_14(ctx) {
	let button;
	let b;
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			b = element("b");
			t = text("B");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { title: true, class: true });
			var button_nodes = children(button);
			b = claim_element(button_nodes, "B", {});
			var b_nodes = children(b);
			t = claim_text(b_nodes, "B");
			b_nodes.forEach(detach);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "title", "Bold the selected text");
			attr(button, "class", "svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, b);
			append(b, t);

			if (!mounted) {
				dispose = [
					listen(button, "click", function () {
						if (is_function(/*textarea*/ ctx[1].focus())) /*textarea*/ ctx[1].focus().apply(this, arguments);
					}),
					listen(button, "click", prevent_default(/*click_handler*/ ctx[10]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (39:4) {#if options("italic") || options("all")}
function create_if_block_13(ctx) {
	let button;
	let i;
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			i = element("i");
			t = text("I");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { title: true, class: true });
			var button_nodes = children(button);
			i = claim_element(button_nodes, "I", {});
			var i_nodes = children(i);
			t = claim_text(i_nodes, "I");
			i_nodes.forEach(detach);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "title", "Italicize the selected text");
			attr(button, "class", "svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, i);
			append(i, t);

			if (!mounted) {
				dispose = [
					listen(button, "click", function () {
						if (is_function(/*textarea*/ ctx[1].focus())) /*textarea*/ ctx[1].focus().apply(this, arguments);
					}),
					listen(button, "click", prevent_default(/*click_handler_1*/ ctx[11]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (44:4) {#if options("underline") || options("all")}
function create_if_block_12(ctx) {
	let button;
	let u;
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			u = element("u");
			t = text("U");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { title: true, class: true });
			var button_nodes = children(button);
			u = claim_element(button_nodes, "U", {});
			var u_nodes = children(u);
			t = claim_text(u_nodes, "U");
			u_nodes.forEach(detach);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "title", "Underline the selected text");
			attr(button, "class", "svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, u);
			append(u, t);

			if (!mounted) {
				dispose = [
					listen(button, "click", function () {
						if (is_function(/*textarea*/ ctx[1].focus())) /*textarea*/ ctx[1].focus().apply(this, arguments);
					}),
					listen(button, "click", prevent_default(/*click_handler_2*/ ctx[12]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (49:4) {#if options("bold") || options("italic") || options("underline") || options("all")}
function create_if_block_11(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "spacer svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (52:4) {#if options("bullets") || options("all")}
function create_if_block_10(ctx) {
	let button;
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let circle0;
	let circle1;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);

			svg = claim_element(
				button_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			path2 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path2).forEach(detach);
			path3 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path3).forEach(detach);
			circle0 = claim_element(svg_nodes, "circle", { cx: true, r: true, cy: true }, 1);
			children(circle0).forEach(detach);
			circle1 = claim_element(svg_nodes, "circle", { cx: true, r: true, cy: true }, 1);
			children(circle1).forEach(detach);
			svg_nodes.forEach(detach);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M11 6h9");
			attr(path2, "d", "M11 12h9");
			attr(path3, "d", "M12 18h8");
			attr(circle0, "cx", "5");
			attr(circle0, "r", "2");
			attr(circle0, "cy", "7");
			attr(circle1, "cx", "5");
			attr(circle1, "r", "2");
			attr(circle1, "cy", "17");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-list-numbers-MODIFIED svelte-dcpxpi");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "1.5");
			attr(svg, "stroke", "black");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(button, "class", "svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, svg);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
			append(svg, circle0);
			append(svg, circle1);

			if (!mounted) {
				dispose = [
					listen(button, "click", function () {
						if (is_function(/*textarea*/ ctx[1].focus())) /*textarea*/ ctx[1].focus().apply(this, arguments);
					}),
					listen(button, "click", prevent_default(/*click_handler_3*/ ctx[13]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (64:4) {#if options("numbers") || options("all")}
function create_if_block_9(ctx) {
	let button;
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let path5;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			path5 = svg_element("path");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);

			svg = claim_element(
				button_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			path2 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path2).forEach(detach);
			path3 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path3).forEach(detach);
			path4 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path4).forEach(detach);
			path5 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path5).forEach(detach);
			svg_nodes.forEach(detach);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M11 6h9");
			attr(path2, "d", "M11 12h9");
			attr(path3, "d", "M12 18h8");
			attr(path4, "d", "M4 16a2 2 0 1 1 4 0c0 .591 -.5 1 -1 1.5l-3 2.5h4");
			attr(path5, "d", "M6 10v-6l-2 2");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-list-numbers svelte-dcpxpi");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "1.5");
			attr(svg, "stroke", "black");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(button, "class", "svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, svg);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
			append(svg, path4);
			append(svg, path5);

			if (!mounted) {
				dispose = [
					listen(button, "click", function () {
						if (is_function(/*textarea*/ ctx[1].focus())) /*textarea*/ ctx[1].focus().apply(this, arguments);
					}),
					listen(button, "click", prevent_default(/*click_handler_4*/ ctx[14]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (76:4) {#if options("bullets") || options("numbers") || options("all")}
function create_if_block_8(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "spacer svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (79:4) {#if options("link") || options("all")}
function create_if_block_7(ctx) {
	let button;
	let svg;
	let path0;
	let path1;
	let path2;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);

			svg = claim_element(
				button_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			path2 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path2).forEach(detach);
			svg_nodes.forEach(detach);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5");
			attr(path2, "d", "M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-link svelte-dcpxpi");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "1.5");
			attr(svg, "stroke", "black");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(button, "class", "svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, svg);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);

			if (!mounted) {
				dispose = [
					listen(button, "click", function () {
						if (is_function(/*textarea*/ ctx[1].focus())) /*textarea*/ ctx[1].focus().apply(this, arguments);
					}),
					listen(button, "click", /*createLink*/ ctx[5]),
					listen(button, "click", prevent_default(/*click_handler_5*/ ctx[15]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (88:4) {#if options("unlink") || options("all")}
function create_if_block_6(ctx) {
	let button;
	let svg;
	let path0;
	let path1;
	let path2;
	let line0;
	let line1;
	let line2;
	let line3;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);

			svg = claim_element(
				button_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			path2 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path2).forEach(detach);
			line0 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach);
			line1 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach);
			line2 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line2).forEach(detach);
			line3 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line3).forEach(detach);
			svg_nodes.forEach(detach);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5");
			attr(path2, "d", "M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5");
			attr(line0, "x1", "16");
			attr(line0, "y1", "21");
			attr(line0, "x2", "16");
			attr(line0, "y2", "19");
			attr(line1, "x1", "19");
			attr(line1, "y1", "16");
			attr(line1, "x2", "21");
			attr(line1, "y2", "16");
			attr(line2, "x1", "3");
			attr(line2, "y1", "8");
			attr(line2, "x2", "5");
			attr(line2, "y2", "8");
			attr(line3, "x1", "8");
			attr(line3, "y1", "3");
			attr(line3, "x2", "8");
			attr(line3, "y2", "5");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-unlink svelte-dcpxpi");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "1.5");
			attr(svg, "stroke", "black");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(button, "class", "svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, svg);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, line0);
			append(svg, line1);
			append(svg, line2);
			append(svg, line3);

			if (!mounted) {
				dispose = [
					listen(button, "click", function () {
						if (is_function(/*textarea*/ ctx[1].focus())) /*textarea*/ ctx[1].focus().apply(this, arguments);
					}),
					listen(button, "click", prevent_default(/*click_handler_6*/ ctx[16]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (101:4) {#if options("link") || options("unlink") || options("all")}
function create_if_block_5(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "spacer svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (104:4) {#if options("heading1") || options("all")}
function create_if_block_4(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text("h1");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { title: true, class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "h1");
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "title", "Heading level one");
			attr(button, "class", "svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = [
					listen(button, "click", function () {
						if (is_function(/*textarea*/ ctx[1].focus())) /*textarea*/ ctx[1].focus().apply(this, arguments);
					}),
					listen(button, "click", prevent_default(/*click_handler_7*/ ctx[17]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (109:4) {#if options("heading2") || options("all")}
function create_if_block_3(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text("h2");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { title: true, class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "h2");
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "title", "Heading level two");
			attr(button, "class", "svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = [
					listen(button, "click", function () {
						if (is_function(/*textarea*/ ctx[1].focus())) /*textarea*/ ctx[1].focus().apply(this, arguments);
					}),
					listen(button, "click", prevent_default(/*click_handler_8*/ ctx[18]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (114:4) {#if options("heading3") || options("all")}
function create_if_block_2(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text("h3");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { title: true, class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "h3");
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "title", "Heading level three");
			attr(button, "class", "svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = [
					listen(button, "click", function () {
						if (is_function(/*textarea*/ ctx[1].focus())) /*textarea*/ ctx[1].focus().apply(this, arguments);
					}),
					listen(button, "click", prevent_default(/*click_handler_9*/ ctx[19]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (119:4) {#if options("heading1") || options("heading2") || options("heading3") || options("all")}
function create_if_block_1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "spacer svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (122:4) {#if options("clear") || options("all")}
function create_if_block(ctx) {
	let button;
	let svg;
	let path0;
	let path1;
	let path2;
	let line0;
	let line1;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);

			svg = claim_element(
				button_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			path2 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path2).forEach(detach);
			line0 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach);
			line1 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach);
			svg_nodes.forEach(detach);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M17 15l4 4m0 -4l-4 4");
			attr(path2, "d", "M7 6v-1h11v1");
			attr(line0, "x1", "7");
			attr(line0, "y1", "19");
			attr(line0, "x2", "11");
			attr(line0, "y2", "19");
			attr(line1, "x1", "13");
			attr(line1, "y1", "5");
			attr(line1, "x2", "9");
			attr(line1, "y2", "19");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-clear-formatting svelte-dcpxpi");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "1.5");
			attr(svg, "stroke", "black");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(button, "class", "svelte-dcpxpi");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, svg);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, line0);
			append(svg, line1);

			if (!mounted) {
				dispose = [
					listen(button, "click", function () {
						if (is_function(/*textarea*/ ctx[1].focus())) /*textarea*/ ctx[1].focus().apply(this, arguments);
					}),
					listen(button, "click", prevent_default(/*click_handler_10*/ ctx[20]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let div0;
	let show_if_14 = /*options*/ ctx[7]("bold") || /*options*/ ctx[7]("all");
	let t0;
	let show_if_13 = /*options*/ ctx[7]("italic") || /*options*/ ctx[7]("all");
	let t1;
	let show_if_12 = /*options*/ ctx[7]("underline") || /*options*/ ctx[7]("all");
	let t2;
	let show_if_11 = /*options*/ ctx[7]("bold") || /*options*/ ctx[7]("italic") || /*options*/ ctx[7]("underline") || /*options*/ ctx[7]("all");
	let t3;
	let show_if_10 = /*options*/ ctx[7]("bullets") || /*options*/ ctx[7]("all");
	let t4;
	let show_if_9 = /*options*/ ctx[7]("numbers") || /*options*/ ctx[7]("all");
	let t5;
	let show_if_8 = /*options*/ ctx[7]("bullets") || /*options*/ ctx[7]("numbers") || /*options*/ ctx[7]("all");
	let t6;
	let show_if_7 = /*options*/ ctx[7]("link") || /*options*/ ctx[7]("all");
	let t7;
	let show_if_6 = /*options*/ ctx[7]("unlink") || /*options*/ ctx[7]("all");
	let t8;
	let show_if_5 = /*options*/ ctx[7]("link") || /*options*/ ctx[7]("unlink") || /*options*/ ctx[7]("all");
	let t9;
	let show_if_4 = /*options*/ ctx[7]("heading1") || /*options*/ ctx[7]("all");
	let t10;
	let show_if_3 = /*options*/ ctx[7]("heading2") || /*options*/ ctx[7]("all");
	let t11;
	let show_if_2 = /*options*/ ctx[7]("heading3") || /*options*/ ctx[7]("all");
	let t12;
	let show_if_1 = /*options*/ ctx[7]("heading1") || /*options*/ ctx[7]("heading2") || /*options*/ ctx[7]("heading3") || /*options*/ ctx[7]("all");
	let t13;
	let show_if = /*options*/ ctx[7]("clear") || /*options*/ ctx[7]("all");
	let t14;
	let div1;
	let mounted;
	let dispose;
	let if_block0 = show_if_14 && create_if_block_14(ctx);
	let if_block1 = show_if_13 && create_if_block_13(ctx);
	let if_block2 = show_if_12 && create_if_block_12(ctx);
	let if_block3 = show_if_11 && create_if_block_11(ctx);
	let if_block4 = show_if_10 && create_if_block_10(ctx);
	let if_block5 = show_if_9 && create_if_block_9(ctx);
	let if_block6 = show_if_8 && create_if_block_8(ctx);
	let if_block7 = show_if_7 && create_if_block_7(ctx);
	let if_block8 = show_if_6 && create_if_block_6(ctx);
	let if_block9 = show_if_5 && create_if_block_5(ctx);
	let if_block10 = show_if_4 && create_if_block_4(ctx);
	let if_block11 = show_if_3 && create_if_block_3(ctx);
	let if_block12 = show_if_2 && create_if_block_2(ctx);
	let if_block13 = show_if_1 && create_if_block_1(ctx);
	let if_block14 = show_if && create_if_block(ctx);

	return {
		c() {
			div0 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			t4 = space();
			if (if_block5) if_block5.c();
			t5 = space();
			if (if_block6) if_block6.c();
			t6 = space();
			if (if_block7) if_block7.c();
			t7 = space();
			if (if_block8) if_block8.c();
			t8 = space();
			if (if_block9) if_block9.c();
			t9 = space();
			if (if_block10) if_block10.c();
			t10 = space();
			if (if_block11) if_block11.c();
			t11 = space();
			if (if_block12) if_block12.c();
			t12 = space();
			if (if_block13) if_block13.c();
			t13 = space();
			if (if_block14) if_block14.c();
			t14 = space();
			div1 = element("div");
			this.h();
		},
		l(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (if_block0) if_block0.l(div0_nodes);
			t0 = claim_space(div0_nodes);
			if (if_block1) if_block1.l(div0_nodes);
			t1 = claim_space(div0_nodes);
			if (if_block2) if_block2.l(div0_nodes);
			t2 = claim_space(div0_nodes);
			if (if_block3) if_block3.l(div0_nodes);
			t3 = claim_space(div0_nodes);
			if (if_block4) if_block4.l(div0_nodes);
			t4 = claim_space(div0_nodes);
			if (if_block5) if_block5.l(div0_nodes);
			t5 = claim_space(div0_nodes);
			if (if_block6) if_block6.l(div0_nodes);
			t6 = claim_space(div0_nodes);
			if (if_block7) if_block7.l(div0_nodes);
			t7 = claim_space(div0_nodes);
			if (if_block8) if_block8.l(div0_nodes);
			t8 = claim_space(div0_nodes);
			if (if_block9) if_block9.l(div0_nodes);
			t9 = claim_space(div0_nodes);
			if (if_block10) if_block10.l(div0_nodes);
			t10 = claim_space(div0_nodes);
			if (if_block11) if_block11.l(div0_nodes);
			t11 = claim_space(div0_nodes);
			if (if_block12) if_block12.l(div0_nodes);
			t12 = claim_space(div0_nodes);
			if (if_block13) if_block13.l(div0_nodes);
			t13 = claim_space(div0_nodes);
			if (if_block14) if_block14.l(div0_nodes);
			div0_nodes.forEach(detach);
			t14 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true, contenteditable: true });
			children(div1).forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "editor svelte-dcpxpi");
			attr(div1, "class", "textarea svelte-dcpxpi");
			attr(div1, "contenteditable", "true");
			if (/*field*/ ctx[0] === void 0) add_render_callback(() => /*div1_input_handler*/ ctx[21].call(div1));
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			if (if_block0) if_block0.m(div0, null);
			append(div0, t0);
			if (if_block1) if_block1.m(div0, null);
			append(div0, t1);
			if (if_block2) if_block2.m(div0, null);
			append(div0, t2);
			if (if_block3) if_block3.m(div0, null);
			append(div0, t3);
			if (if_block4) if_block4.m(div0, null);
			append(div0, t4);
			if (if_block5) if_block5.m(div0, null);
			append(div0, t5);
			if (if_block6) if_block6.m(div0, null);
			append(div0, t6);
			if (if_block7) if_block7.m(div0, null);
			append(div0, t7);
			if (if_block8) if_block8.m(div0, null);
			append(div0, t8);
			if (if_block9) if_block9.m(div0, null);
			append(div0, t9);
			if (if_block10) if_block10.m(div0, null);
			append(div0, t10);
			if (if_block11) if_block11.m(div0, null);
			append(div0, t11);
			if (if_block12) if_block12.m(div0, null);
			append(div0, t12);
			if (if_block13) if_block13.m(div0, null);
			append(div0, t13);
			if (if_block14) if_block14.m(div0, null);
			insert(target, t14, anchor);
			insert(target, div1, anchor);

			if (/*field*/ ctx[0] !== void 0) {
				div1.innerHTML = /*field*/ ctx[0];
			}

			/*div1_binding*/ ctx[22](div1);

			if (!mounted) {
				dispose = listen(div1, "input", /*div1_input_handler*/ ctx[21]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (show_if_14) if_block0.p(ctx, dirty);
			if (show_if_13) if_block1.p(ctx, dirty);
			if (show_if_12) if_block2.p(ctx, dirty);
			if (show_if_10) if_block4.p(ctx, dirty);
			if (show_if_9) if_block5.p(ctx, dirty);
			if (show_if_7) if_block7.p(ctx, dirty);
			if (show_if_6) if_block8.p(ctx, dirty);
			if (show_if_4) if_block10.p(ctx, dirty);
			if (show_if_3) if_block11.p(ctx, dirty);
			if (show_if_2) if_block12.p(ctx, dirty);
			if (show_if) if_block14.p(ctx, dirty);

			if (dirty & /*field*/ 1 && /*field*/ ctx[0] !== div1.innerHTML) {
				div1.innerHTML = /*field*/ ctx[0];
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div0);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (if_block7) if_block7.d();
			if (if_block8) if_block8.d();
			if (if_block9) if_block9.d();
			if (if_block10) if_block10.d();
			if (if_block11) if_block11.d();
			if (if_block12) if_block12.d();
			if (if_block13) if_block13.d();
			if (if_block14) if_block14.d();
			if (detaching) detach(t14);
			if (detaching) detach(div1);
			/*div1_binding*/ ctx[22](null);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { schema } = $$props, { parentKeys } = $$props, { field } = $$props;
	let textarea;
	let linkURL, linkText, linkOptions;

	const createLink = () => {
		$$invalidate(2, linkURL = prompt("Enter a URL:", "http://"));
		let selectedText = document.getSelection().toString();

		if (selectedText.length > 0) {
			$$invalidate(3, linkText = selectedText);
		} else {
			$$invalidate(3, linkText = prompt("Link Text:", ""));
		}

		let newTab = prompt("Open link in new tab? (yes/no)", "no");

		if (newTab === "yes" || newTab === "y") {
			$$invalidate(4, linkOptions = "target='_blank' rel='noreferrer noopener'");
		}
	};

	const heading = level => {
		let s = window.getSelection();

		if (s.baseNode.parentNode.tagName === level.toUpperCase()) {
			document.execCommand("formatBlock", false, "div");
		} else {
			document.execCommand("insertHTML", false, "<" + level + ">" + s + "</" + level + ">");
		}
	};

	const options = option => schema[parentKeys].options.includes(option);
	const click_handler = () => document.execCommand("bold");
	const click_handler_1 = () => document.execCommand("italic");
	const click_handler_2 = () => document.execCommand("underline");
	const click_handler_3 = () => document.execCommand("insertUnorderedList");
	const click_handler_4 = () => document.execCommand("insertOrderedList");
	const click_handler_5 = () => document.execCommand("insertHTML", false, "<a href='" + linkURL + "' " + linkOptions + ">" + linkText + "</a>");
	const click_handler_6 = () => document.execCommand("unlink");
	const click_handler_7 = () => heading("h1");
	const click_handler_8 = () => heading("h2");
	const click_handler_9 = () => heading("h3");
	const click_handler_10 = () => document.execCommand("removeFormat");

	function div1_input_handler() {
		field = this.innerHTML;
		$$invalidate(0, field);
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			textarea = $$value;
			$$invalidate(1, textarea);
		});
	}

	$$self.$$set = $$props => {
		if ("schema" in $$props) $$invalidate(8, schema = $$props.schema);
		if ("parentKeys" in $$props) $$invalidate(9, parentKeys = $$props.parentKeys);
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
	};

	return [
		field,
		textarea,
		linkURL,
		linkText,
		linkOptions,
		createLink,
		heading,
		options,
		schema,
		parentKeys,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		click_handler_7,
		click_handler_8,
		click_handler_9,
		click_handler_10,
		div1_input_handler,
		div1_binding
	];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { schema: 8, parentKeys: 9, field: 0 });
	}
}

export default Component;