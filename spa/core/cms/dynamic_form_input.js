/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	check_outros,
	children,
	claim_component,
	claim_element,
	claim_space,
	claim_text,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out
} from '../../web_modules/svelte/internal/index.mjs';

import { isDate, isTime } from './date_checker.js';
import { isMediaPath } from './media_checker.js';
import Checkbox from './fields/checkbox.js';
import Radio from './fields/radio.js';
import Wysiwyg from './fields/wysiwyg.js';
import Component from './fields/component.js';
import Fieldset from './fields/fieldset.js';
import Media from './fields/media.js';
import Select from './fields/select.js';
import Autocomplete from './fields/autocomplete.js';
import ID from './fields/id.js';
import Date from './fields/date.js';
import Time from './fields/time.js';
import Number from './fields/number.js';
import Text from './fields/text.js';
import Boolean from './fields/boolean.js';

function create_if_block(ctx) {
	let div;
	let t;
	let show_if;
	let current_block_type_index;
	let if_block1;
	let div_class_value;
	let current;
	let if_block0 = /*label*/ ctx[4] && create_if_block_25(ctx);

	const if_block_creators = [
		create_if_block_1,
		create_if_block_15,
		create_if_block_16,
		create_if_block_20,
		create_if_block_21,
		create_if_block_22,
		create_if_block_23,
		create_if_block_24
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty[0] & /*schema, parentKeys*/ 96) show_if = !!(/*schema*/ ctx[6] && /*schema*/ ctx[6].hasOwnProperty(/*parentKeys*/ ctx[5]));
		if (show_if) return 0;
		if (typeof /*field*/ ctx[0] === "number") return 1;
		if (typeof /*field*/ ctx[0] === "string") return 2;
		if (typeof /*field*/ ctx[0] === "boolean") return 3;
		if (/*field*/ ctx[0].constructor === [].constructor) return 4;
		if (/*field*/ ctx[0].constructor === ({}).constructor) return 5;
		if (/*field*/ ctx[0] === null) return 6;
		if (/*field*/ ctx[0] === undefined) return 7;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", div_class_value = "field " + /*label*/ ctx[4] + " svelte-1wlycgm");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_25(ctx);
					if_block0.c();
					if_block0.m(div, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block1) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div, null);
				} else {
					if_block1 = null;
				}
			}

			if (!current || dirty[0] & /*label*/ 16 && div_class_value !== (div_class_value = "field " + /*label*/ ctx[4] + " svelte-1wlycgm")) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

// (29:4) {#if label}
function create_if_block_25(ctx) {
	let label_1;
	let t;

	return {
		c() {
			label_1 = element("label");
			t = text(/*label*/ ctx[4]);
			this.h();
		},
		l(nodes) {
			label_1 = claim_element(nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			t = claim_text(label_1_nodes, /*label*/ ctx[4]);
			label_1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(label_1, "for", /*label*/ ctx[4]);
			attr(label_1, "class", "svelte-1wlycgm");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			append(label_1, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*label*/ 16) set_data(t, /*label*/ ctx[4]);

			if (dirty[0] & /*label*/ 16) {
				attr(label_1, "for", /*label*/ ctx[4]);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (92:34) 
function create_if_block_24(ctx) {
	let div;
	let t;

	return {
		c() {
			div = element("div");
			t = text("field is undefined");
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t = claim_text(div_nodes, "field is undefined");
			div_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (90:29) 
function create_if_block_23(ctx) {
	let div;
	let t;

	return {
		c() {
			div = element("div");
			t = text("field is null");
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t = claim_text(div_nodes, "field is null");
			div_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (88:53) 
function create_if_block_22(ctx) {
	let fieldset;
	let updating_field;
	let updating_showMediaModal;
	let updating_changingMedia;
	let updating_localMediaList;
	let current;

	function fieldset_field_binding(value) {
		/*fieldset_field_binding*/ ctx[40](value);
	}

	function fieldset_showMediaModal_binding(value) {
		/*fieldset_showMediaModal_binding*/ ctx[41](value);
	}

	function fieldset_changingMedia_binding(value) {
		/*fieldset_changingMedia_binding*/ ctx[42](value);
	}

	function fieldset_localMediaList_binding(value) {
		/*fieldset_localMediaList_binding*/ ctx[43](value);
	}

	let fieldset_props = {
		parentKeys: /*parentKeys*/ ctx[5],
		schema: /*schema*/ ctx[6]
	};

	if (/*field*/ ctx[0] !== void 0) {
		fieldset_props.field = /*field*/ ctx[0];
	}

	if (/*showMediaModal*/ ctx[1] !== void 0) {
		fieldset_props.showMediaModal = /*showMediaModal*/ ctx[1];
	}

	if (/*changingMedia*/ ctx[2] !== void 0) {
		fieldset_props.changingMedia = /*changingMedia*/ ctx[2];
	}

	if (/*localMediaList*/ ctx[3] !== void 0) {
		fieldset_props.localMediaList = /*localMediaList*/ ctx[3];
	}

	fieldset = new Fieldset({ props: fieldset_props });
	binding_callbacks.push(() => bind(fieldset, "field", fieldset_field_binding));
	binding_callbacks.push(() => bind(fieldset, "showMediaModal", fieldset_showMediaModal_binding));
	binding_callbacks.push(() => bind(fieldset, "changingMedia", fieldset_changingMedia_binding));
	binding_callbacks.push(() => bind(fieldset, "localMediaList", fieldset_localMediaList_binding));

	return {
		c() {
			create_component(fieldset.$$.fragment);
		},
		l(nodes) {
			claim_component(fieldset.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(fieldset, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const fieldset_changes = {};
			if (dirty[0] & /*parentKeys*/ 32) fieldset_changes.parentKeys = /*parentKeys*/ ctx[5];
			if (dirty[0] & /*schema*/ 64) fieldset_changes.schema = /*schema*/ ctx[6];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				fieldset_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			if (!updating_showMediaModal && dirty[0] & /*showMediaModal*/ 2) {
				updating_showMediaModal = true;
				fieldset_changes.showMediaModal = /*showMediaModal*/ ctx[1];
				add_flush_callback(() => updating_showMediaModal = false);
			}

			if (!updating_changingMedia && dirty[0] & /*changingMedia*/ 4) {
				updating_changingMedia = true;
				fieldset_changes.changingMedia = /*changingMedia*/ ctx[2];
				add_flush_callback(() => updating_changingMedia = false);
			}

			if (!updating_localMediaList && dirty[0] & /*localMediaList*/ 8) {
				updating_localMediaList = true;
				fieldset_changes.localMediaList = /*localMediaList*/ ctx[3];
				add_flush_callback(() => updating_localMediaList = false);
			}

			fieldset.$set(fieldset_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fieldset.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fieldset.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(fieldset, detaching);
		}
	};
}

// (86:51) 
function create_if_block_21(ctx) {
	let component;
	let updating_field;
	let updating_showMediaModal;
	let updating_changingMedia;
	let updating_localMediaList;
	let current;

	function component_field_binding_1(value) {
		/*component_field_binding_1*/ ctx[36](value);
	}

	function component_showMediaModal_binding_1(value) {
		/*component_showMediaModal_binding_1*/ ctx[37](value);
	}

	function component_changingMedia_binding_1(value) {
		/*component_changingMedia_binding_1*/ ctx[38](value);
	}

	function component_localMediaList_binding_1(value) {
		/*component_localMediaList_binding_1*/ ctx[39](value);
	}

	let component_props = {
		parentKeys: /*parentKeys*/ ctx[5],
		schema: /*schema*/ ctx[6]
	};

	if (/*field*/ ctx[0] !== void 0) {
		component_props.field = /*field*/ ctx[0];
	}

	if (/*showMediaModal*/ ctx[1] !== void 0) {
		component_props.showMediaModal = /*showMediaModal*/ ctx[1];
	}

	if (/*changingMedia*/ ctx[2] !== void 0) {
		component_props.changingMedia = /*changingMedia*/ ctx[2];
	}

	if (/*localMediaList*/ ctx[3] !== void 0) {
		component_props.localMediaList = /*localMediaList*/ ctx[3];
	}

	component = new Component({ props: component_props });
	binding_callbacks.push(() => bind(component, "field", component_field_binding_1));
	binding_callbacks.push(() => bind(component, "showMediaModal", component_showMediaModal_binding_1));
	binding_callbacks.push(() => bind(component, "changingMedia", component_changingMedia_binding_1));
	binding_callbacks.push(() => bind(component, "localMediaList", component_localMediaList_binding_1));

	return {
		c() {
			create_component(component.$$.fragment);
		},
		l(nodes) {
			claim_component(component.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(component, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const component_changes = {};
			if (dirty[0] & /*parentKeys*/ 32) component_changes.parentKeys = /*parentKeys*/ ctx[5];
			if (dirty[0] & /*schema*/ 64) component_changes.schema = /*schema*/ ctx[6];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				component_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			if (!updating_showMediaModal && dirty[0] & /*showMediaModal*/ 2) {
				updating_showMediaModal = true;
				component_changes.showMediaModal = /*showMediaModal*/ ctx[1];
				add_flush_callback(() => updating_showMediaModal = false);
			}

			if (!updating_changingMedia && dirty[0] & /*changingMedia*/ 4) {
				updating_changingMedia = true;
				component_changes.changingMedia = /*changingMedia*/ ctx[2];
				add_flush_callback(() => updating_changingMedia = false);
			}

			if (!updating_localMediaList && dirty[0] & /*localMediaList*/ 8) {
				updating_localMediaList = true;
				component_changes.localMediaList = /*localMediaList*/ ctx[3];
				add_flush_callback(() => updating_localMediaList = false);
			}

			component.$set(component_changes);
		},
		i(local) {
			if (current) return;
			transition_in(component.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(component.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(component, detaching);
		}
	};
}

// (84:41) 
function create_if_block_20(ctx) {
	let boolean;
	let updating_field;
	let current;

	function boolean_field_binding_1(value) {
		/*boolean_field_binding_1*/ ctx[35](value);
	}

	let boolean_props = { label: /*label*/ ctx[4] };

	if (/*field*/ ctx[0] !== void 0) {
		boolean_props.field = /*field*/ ctx[0];
	}

	boolean = new Boolean({ props: boolean_props });
	binding_callbacks.push(() => bind(boolean, "field", boolean_field_binding_1));

	return {
		c() {
			create_component(boolean.$$.fragment);
		},
		l(nodes) {
			claim_component(boolean.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(boolean, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const boolean_changes = {};
			if (dirty[0] & /*label*/ 16) boolean_changes.label = /*label*/ ctx[4];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				boolean_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			boolean.$set(boolean_changes);
		},
		i(local) {
			if (current) return;
			transition_in(boolean.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(boolean.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(boolean, detaching);
		}
	};
}

// (74:40) 
function create_if_block_16(ctx) {
	let show_if;
	let show_if_1;
	let show_if_2;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_17, create_if_block_18, create_if_block_19, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (dirty[0] & /*field*/ 1) show_if = !!isDate(/*field*/ ctx[0]);
		if (show_if) return 0;
		if (dirty[0] & /*field*/ 1) show_if_1 = !!isTime(/*field*/ ctx[0]);
		if (show_if_1) return 1;
		if (dirty[0] & /*field*/ 1) show_if_2 = !!isMediaPath(/*field*/ ctx[0]);
		if (show_if_2) return 2;
		return 3;
	}

	current_block_type_index = select_block_type_1(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (72:40) 
function create_if_block_15(ctx) {
	let number;
	let updating_field;
	let current;

	function number_field_binding_1(value) {
		/*number_field_binding_1*/ ctx[27](value);
	}

	let number_props = { label: /*label*/ ctx[4] };

	if (/*field*/ ctx[0] !== void 0) {
		number_props.field = /*field*/ ctx[0];
	}

	number = new Number({ props: number_props });
	binding_callbacks.push(() => bind(number, "field", number_field_binding_1));

	return {
		c() {
			create_component(number.$$.fragment);
		},
		l(nodes) {
			claim_component(number.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(number, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const number_changes = {};
			if (dirty[0] & /*label*/ 16) number_changes.label = /*label*/ ctx[4];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				number_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			number.$set(number_changes);
		},
		i(local) {
			if (current) return;
			transition_in(number.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(number.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(number, detaching);
		}
	};
}

// (32:4) {#if schema && schema.hasOwnProperty(parentKeys)}
function create_if_block_1(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let if_block12_anchor;
	let current;
	let if_block0 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "component" && create_if_block_14(ctx);
	let if_block1 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "checkbox" && create_if_block_13(ctx);
	let if_block2 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "radio" && create_if_block_12(ctx);
	let if_block3 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "select" && create_if_block_11(ctx);
	let if_block4 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "wysiwyg" && create_if_block_10(ctx);
	let if_block5 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "autocomplete" && create_if_block_9(ctx);
	let if_block6 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "id" && create_if_block_8(ctx);
	let if_block7 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "text" && create_if_block_7(ctx);
	let if_block8 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "number" && create_if_block_6(ctx);
	let if_block9 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "boolean" && create_if_block_5(ctx);
	let if_block10 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "date" && create_if_block_4(ctx);
	let if_block11 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "time" && create_if_block_3(ctx);
	let if_block12 = /*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "media" && create_if_block_2(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			t4 = space();
			if (if_block5) if_block5.c();
			t5 = space();
			if (if_block6) if_block6.c();
			t6 = space();
			if (if_block7) if_block7.c();
			t7 = space();
			if (if_block8) if_block8.c();
			t8 = space();
			if (if_block9) if_block9.c();
			t9 = space();
			if (if_block10) if_block10.c();
			t10 = space();
			if (if_block11) if_block11.c();
			t11 = space();
			if (if_block12) if_block12.c();
			if_block12_anchor = empty();
		},
		l(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t1 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			t2 = claim_space(nodes);
			if (if_block3) if_block3.l(nodes);
			t3 = claim_space(nodes);
			if (if_block4) if_block4.l(nodes);
			t4 = claim_space(nodes);
			if (if_block5) if_block5.l(nodes);
			t5 = claim_space(nodes);
			if (if_block6) if_block6.l(nodes);
			t6 = claim_space(nodes);
			if (if_block7) if_block7.l(nodes);
			t7 = claim_space(nodes);
			if (if_block8) if_block8.l(nodes);
			t8 = claim_space(nodes);
			if (if_block9) if_block9.l(nodes);
			t9 = claim_space(nodes);
			if (if_block10) if_block10.l(nodes);
			t10 = claim_space(nodes);
			if (if_block11) if_block11.l(nodes);
			t11 = claim_space(nodes);
			if (if_block12) if_block12.l(nodes);
			if_block12_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t2, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert(target, t3, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert(target, t4, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert(target, t5, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert(target, t6, anchor);
			if (if_block7) if_block7.m(target, anchor);
			insert(target, t7, anchor);
			if (if_block8) if_block8.m(target, anchor);
			insert(target, t8, anchor);
			if (if_block9) if_block9.m(target, anchor);
			insert(target, t9, anchor);
			if (if_block10) if_block10.m(target, anchor);
			insert(target, t10, anchor);
			if (if_block11) if_block11.m(target, anchor);
			insert(target, t11, anchor);
			if (if_block12) if_block12.m(target, anchor);
			insert(target, if_block12_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "component") {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_14(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "checkbox") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_13(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "radio") {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_12(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(t2.parentNode, t2);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "select") {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_11(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t3.parentNode, t3);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "wysiwyg") {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_10(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t4.parentNode, t4);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "autocomplete") {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_9(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t5.parentNode, t5);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "id") {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_8(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(t6.parentNode, t6);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "text") {
				if (if_block7) {
					if_block7.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block7, 1);
					}
				} else {
					if_block7 = create_if_block_7(ctx);
					if_block7.c();
					transition_in(if_block7, 1);
					if_block7.m(t7.parentNode, t7);
				}
			} else if (if_block7) {
				group_outros();

				transition_out(if_block7, 1, 1, () => {
					if_block7 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "number") {
				if (if_block8) {
					if_block8.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block8, 1);
					}
				} else {
					if_block8 = create_if_block_6(ctx);
					if_block8.c();
					transition_in(if_block8, 1);
					if_block8.m(t8.parentNode, t8);
				}
			} else if (if_block8) {
				group_outros();

				transition_out(if_block8, 1, 1, () => {
					if_block8 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "boolean") {
				if (if_block9) {
					if_block9.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block9, 1);
					}
				} else {
					if_block9 = create_if_block_5(ctx);
					if_block9.c();
					transition_in(if_block9, 1);
					if_block9.m(t9.parentNode, t9);
				}
			} else if (if_block9) {
				group_outros();

				transition_out(if_block9, 1, 1, () => {
					if_block9 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "date") {
				if (if_block10) {
					if_block10.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block10, 1);
					}
				} else {
					if_block10 = create_if_block_4(ctx);
					if_block10.c();
					transition_in(if_block10, 1);
					if_block10.m(t10.parentNode, t10);
				}
			} else if (if_block10) {
				group_outros();

				transition_out(if_block10, 1, 1, () => {
					if_block10 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "time") {
				if (if_block11) {
					if_block11.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block11, 1);
					}
				} else {
					if_block11 = create_if_block_3(ctx);
					if_block11.c();
					transition_in(if_block11, 1);
					if_block11.m(t11.parentNode, t11);
				}
			} else if (if_block11) {
				group_outros();

				transition_out(if_block11, 1, 1, () => {
					if_block11 = null;
				});

				check_outros();
			}

			if (/*schema*/ ctx[6][/*parentKeys*/ ctx[5]].type === "media") {
				if (if_block12) {
					if_block12.p(ctx, dirty);

					if (dirty[0] & /*schema, parentKeys*/ 96) {
						transition_in(if_block12, 1);
					}
				} else {
					if_block12 = create_if_block_2(ctx);
					if_block12.c();
					transition_in(if_block12, 1);
					if_block12.m(if_block12_anchor.parentNode, if_block12_anchor);
				}
			} else if (if_block12) {
				group_outros();

				transition_out(if_block12, 1, 1, () => {
					if_block12 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(if_block5);
			transition_in(if_block6);
			transition_in(if_block7);
			transition_in(if_block8);
			transition_in(if_block9);
			transition_in(if_block10);
			transition_in(if_block11);
			transition_in(if_block12);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(if_block5);
			transition_out(if_block6);
			transition_out(if_block7);
			transition_out(if_block8);
			transition_out(if_block9);
			transition_out(if_block10);
			transition_out(if_block11);
			transition_out(if_block12);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(t2);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(t3);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach(t4);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach(t5);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach(t6);
			if (if_block7) if_block7.d(detaching);
			if (detaching) detach(t7);
			if (if_block8) if_block8.d(detaching);
			if (detaching) detach(t8);
			if (if_block9) if_block9.d(detaching);
			if (detaching) detach(t9);
			if (if_block10) if_block10.d(detaching);
			if (detaching) detach(t10);
			if (if_block11) if_block11.d(detaching);
			if (detaching) detach(t11);
			if (if_block12) if_block12.d(detaching);
			if (detaching) detach(if_block12_anchor);
		}
	};
}

// (81:8) {:else}
function create_else_block(ctx) {
	let text_1;
	let updating_field;
	let current;

	function text_1_field_binding_1(value) {
		/*text_1_field_binding_1*/ ctx[34](value);
	}

	let text_1_props = {};

	if (/*field*/ ctx[0] !== void 0) {
		text_1_props.field = /*field*/ ctx[0];
	}

	text_1 = new Text({ props: text_1_props });
	binding_callbacks.push(() => bind(text_1, "field", text_1_field_binding_1));

	return {
		c() {
			create_component(text_1.$$.fragment);
		},
		l(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const text_1_changes = {};

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				text_1_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			text_1.$set(text_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(text_1, detaching);
		}
	};
}

// (79:37) 
function create_if_block_19(ctx) {
	let media;
	let updating_field;
	let updating_showMediaModal;
	let updating_changingMedia;
	let updating_localMediaList;
	let current;

	function media_field_binding_1(value) {
		/*media_field_binding_1*/ ctx[30](value);
	}

	function media_showMediaModal_binding_1(value) {
		/*media_showMediaModal_binding_1*/ ctx[31](value);
	}

	function media_changingMedia_binding_1(value) {
		/*media_changingMedia_binding_1*/ ctx[32](value);
	}

	function media_localMediaList_binding_1(value) {
		/*media_localMediaList_binding_1*/ ctx[33](value);
	}

	let media_props = {};

	if (/*field*/ ctx[0] !== void 0) {
		media_props.field = /*field*/ ctx[0];
	}

	if (/*showMediaModal*/ ctx[1] !== void 0) {
		media_props.showMediaModal = /*showMediaModal*/ ctx[1];
	}

	if (/*changingMedia*/ ctx[2] !== void 0) {
		media_props.changingMedia = /*changingMedia*/ ctx[2];
	}

	if (/*localMediaList*/ ctx[3] !== void 0) {
		media_props.localMediaList = /*localMediaList*/ ctx[3];
	}

	media = new Media({ props: media_props });
	binding_callbacks.push(() => bind(media, "field", media_field_binding_1));
	binding_callbacks.push(() => bind(media, "showMediaModal", media_showMediaModal_binding_1));
	binding_callbacks.push(() => bind(media, "changingMedia", media_changingMedia_binding_1));
	binding_callbacks.push(() => bind(media, "localMediaList", media_localMediaList_binding_1));

	return {
		c() {
			create_component(media.$$.fragment);
		},
		l(nodes) {
			claim_component(media.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(media, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const media_changes = {};

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				media_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			if (!updating_showMediaModal && dirty[0] & /*showMediaModal*/ 2) {
				updating_showMediaModal = true;
				media_changes.showMediaModal = /*showMediaModal*/ ctx[1];
				add_flush_callback(() => updating_showMediaModal = false);
			}

			if (!updating_changingMedia && dirty[0] & /*changingMedia*/ 4) {
				updating_changingMedia = true;
				media_changes.changingMedia = /*changingMedia*/ ctx[2];
				add_flush_callback(() => updating_changingMedia = false);
			}

			if (!updating_localMediaList && dirty[0] & /*localMediaList*/ 8) {
				updating_localMediaList = true;
				media_changes.localMediaList = /*localMediaList*/ ctx[3];
				add_flush_callback(() => updating_localMediaList = false);
			}

			media.$set(media_changes);
		},
		i(local) {
			if (current) return;
			transition_in(media.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(media.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(media, detaching);
		}
	};
}

// (77:32) 
function create_if_block_18(ctx) {
	let time;
	let updating_field;
	let current;

	function time_field_binding_1(value) {
		/*time_field_binding_1*/ ctx[29](value);
	}

	let time_props = {};

	if (/*field*/ ctx[0] !== void 0) {
		time_props.field = /*field*/ ctx[0];
	}

	time = new Time({ props: time_props });
	binding_callbacks.push(() => bind(time, "field", time_field_binding_1));

	return {
		c() {
			create_component(time.$$.fragment);
		},
		l(nodes) {
			claim_component(time.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(time, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const time_changes = {};

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				time_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			time.$set(time_changes);
		},
		i(local) {
			if (current) return;
			transition_in(time.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(time.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(time, detaching);
		}
	};
}

// (75:8) {#if isDate(field)}
function create_if_block_17(ctx) {
	let date;
	let updating_field;
	let current;

	function date_field_binding_1(value) {
		/*date_field_binding_1*/ ctx[28](value);
	}

	let date_props = {};

	if (/*field*/ ctx[0] !== void 0) {
		date_props.field = /*field*/ ctx[0];
	}

	date = new Date({ props: date_props });
	binding_callbacks.push(() => bind(date, "field", date_field_binding_1));

	return {
		c() {
			create_component(date.$$.fragment);
		},
		l(nodes) {
			claim_component(date.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(date, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const date_changes = {};

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				date_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			date.$set(date_changes);
		},
		i(local) {
			if (current) return;
			transition_in(date.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(date.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(date, detaching);
		}
	};
}

// (33:8) {#if schema[parentKeys].type === "component"}
function create_if_block_14(ctx) {
	let component;
	let updating_field;
	let updating_showMediaModal;
	let updating_changingMedia;
	let updating_localMediaList;
	let current;

	function component_field_binding(value) {
		/*component_field_binding*/ ctx[8](value);
	}

	function component_showMediaModal_binding(value) {
		/*component_showMediaModal_binding*/ ctx[9](value);
	}

	function component_changingMedia_binding(value) {
		/*component_changingMedia_binding*/ ctx[10](value);
	}

	function component_localMediaList_binding(value) {
		/*component_localMediaList_binding*/ ctx[11](value);
	}

	let component_props = {
		label: /*label*/ ctx[4],
		parentKeys: /*parentKeys*/ ctx[5],
		schema: /*schema*/ ctx[6]
	};

	if (/*field*/ ctx[0] !== void 0) {
		component_props.field = /*field*/ ctx[0];
	}

	if (/*showMediaModal*/ ctx[1] !== void 0) {
		component_props.showMediaModal = /*showMediaModal*/ ctx[1];
	}

	if (/*changingMedia*/ ctx[2] !== void 0) {
		component_props.changingMedia = /*changingMedia*/ ctx[2];
	}

	if (/*localMediaList*/ ctx[3] !== void 0) {
		component_props.localMediaList = /*localMediaList*/ ctx[3];
	}

	component = new Component({ props: component_props });
	binding_callbacks.push(() => bind(component, "field", component_field_binding));
	binding_callbacks.push(() => bind(component, "showMediaModal", component_showMediaModal_binding));
	binding_callbacks.push(() => bind(component, "changingMedia", component_changingMedia_binding));
	binding_callbacks.push(() => bind(component, "localMediaList", component_localMediaList_binding));

	return {
		c() {
			create_component(component.$$.fragment);
		},
		l(nodes) {
			claim_component(component.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(component, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const component_changes = {};
			if (dirty[0] & /*label*/ 16) component_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*parentKeys*/ 32) component_changes.parentKeys = /*parentKeys*/ ctx[5];
			if (dirty[0] & /*schema*/ 64) component_changes.schema = /*schema*/ ctx[6];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				component_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			if (!updating_showMediaModal && dirty[0] & /*showMediaModal*/ 2) {
				updating_showMediaModal = true;
				component_changes.showMediaModal = /*showMediaModal*/ ctx[1];
				add_flush_callback(() => updating_showMediaModal = false);
			}

			if (!updating_changingMedia && dirty[0] & /*changingMedia*/ 4) {
				updating_changingMedia = true;
				component_changes.changingMedia = /*changingMedia*/ ctx[2];
				add_flush_callback(() => updating_changingMedia = false);
			}

			if (!updating_localMediaList && dirty[0] & /*localMediaList*/ 8) {
				updating_localMediaList = true;
				component_changes.localMediaList = /*localMediaList*/ ctx[3];
				add_flush_callback(() => updating_localMediaList = false);
			}

			component.$set(component_changes);
		},
		i(local) {
			if (current) return;
			transition_in(component.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(component.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(component, detaching);
		}
	};
}

// (36:8) {#if schema[parentKeys].type === "checkbox"}
function create_if_block_13(ctx) {
	let checkbox;
	let updating_field;
	let current;

	function checkbox_field_binding(value) {
		/*checkbox_field_binding*/ ctx[12](value);
	}

	let checkbox_props = {
		schema: /*schema*/ ctx[6],
		parentKeys: /*parentKeys*/ ctx[5]
	};

	if (/*field*/ ctx[0] !== void 0) {
		checkbox_props.field = /*field*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props });
	binding_callbacks.push(() => bind(checkbox, "field", checkbox_field_binding));

	return {
		c() {
			create_component(checkbox.$$.fragment);
		},
		l(nodes) {
			claim_component(checkbox.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty[0] & /*schema*/ 64) checkbox_changes.schema = /*schema*/ ctx[6];
			if (dirty[0] & /*parentKeys*/ 32) checkbox_changes.parentKeys = /*parentKeys*/ ctx[5];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				checkbox_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkbox, detaching);
		}
	};
}

// (39:8) {#if schema[parentKeys].type === "radio"}
function create_if_block_12(ctx) {
	let radio;
	let updating_field;
	let current;

	function radio_field_binding(value) {
		/*radio_field_binding*/ ctx[13](value);
	}

	let radio_props = {
		schema: /*schema*/ ctx[6],
		parentKeys: /*parentKeys*/ ctx[5]
	};

	if (/*field*/ ctx[0] !== void 0) {
		radio_props.field = /*field*/ ctx[0];
	}

	radio = new Radio({ props: radio_props });
	binding_callbacks.push(() => bind(radio, "field", radio_field_binding));

	return {
		c() {
			create_component(radio.$$.fragment);
		},
		l(nodes) {
			claim_component(radio.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(radio, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const radio_changes = {};
			if (dirty[0] & /*schema*/ 64) radio_changes.schema = /*schema*/ ctx[6];
			if (dirty[0] & /*parentKeys*/ 32) radio_changes.parentKeys = /*parentKeys*/ ctx[5];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				radio_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			radio.$set(radio_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(radio, detaching);
		}
	};
}

// (42:8) {#if schema[parentKeys].type === "select"}
function create_if_block_11(ctx) {
	let select;
	let updating_field;
	let current;

	function select_field_binding(value) {
		/*select_field_binding*/ ctx[14](value);
	}

	let select_props = {
		schema: /*schema*/ ctx[6],
		parentKeys: /*parentKeys*/ ctx[5]
	};

	if (/*field*/ ctx[0] !== void 0) {
		select_props.field = /*field*/ ctx[0];
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, "field", select_field_binding));

	return {
		c() {
			create_component(select.$$.fragment);
		},
		l(nodes) {
			claim_component(select.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};
			if (dirty[0] & /*schema*/ 64) select_changes.schema = /*schema*/ ctx[6];
			if (dirty[0] & /*parentKeys*/ 32) select_changes.parentKeys = /*parentKeys*/ ctx[5];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				select_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			select.$set(select_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
		}
	};
}

// (45:8) {#if schema[parentKeys].type === "wysiwyg"}
function create_if_block_10(ctx) {
	let wysiwyg;
	let updating_field;
	let current;

	function wysiwyg_field_binding(value) {
		/*wysiwyg_field_binding*/ ctx[15](value);
	}

	let wysiwyg_props = {
		schema: /*schema*/ ctx[6],
		parentKeys: /*parentKeys*/ ctx[5]
	};

	if (/*field*/ ctx[0] !== void 0) {
		wysiwyg_props.field = /*field*/ ctx[0];
	}

	wysiwyg = new Wysiwyg({ props: wysiwyg_props });
	binding_callbacks.push(() => bind(wysiwyg, "field", wysiwyg_field_binding));

	return {
		c() {
			create_component(wysiwyg.$$.fragment);
		},
		l(nodes) {
			claim_component(wysiwyg.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(wysiwyg, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const wysiwyg_changes = {};
			if (dirty[0] & /*schema*/ 64) wysiwyg_changes.schema = /*schema*/ ctx[6];
			if (dirty[0] & /*parentKeys*/ 32) wysiwyg_changes.parentKeys = /*parentKeys*/ ctx[5];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				wysiwyg_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			wysiwyg.$set(wysiwyg_changes);
		},
		i(local) {
			if (current) return;
			transition_in(wysiwyg.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(wysiwyg.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(wysiwyg, detaching);
		}
	};
}

// (48:8) {#if schema[parentKeys].type === "autocomplete"}
function create_if_block_9(ctx) {
	let autocomplete;
	let updating_field;
	let current;

	function autocomplete_field_binding(value) {
		/*autocomplete_field_binding*/ ctx[16](value);
	}

	let autocomplete_props = {
		schema: /*schema*/ ctx[6],
		parentKeys: /*parentKeys*/ ctx[5]
	};

	if (/*field*/ ctx[0] !== void 0) {
		autocomplete_props.field = /*field*/ ctx[0];
	}

	autocomplete = new Autocomplete({ props: autocomplete_props });
	binding_callbacks.push(() => bind(autocomplete, "field", autocomplete_field_binding));

	return {
		c() {
			create_component(autocomplete.$$.fragment);
		},
		l(nodes) {
			claim_component(autocomplete.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(autocomplete, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const autocomplete_changes = {};
			if (dirty[0] & /*schema*/ 64) autocomplete_changes.schema = /*schema*/ ctx[6];
			if (dirty[0] & /*parentKeys*/ 32) autocomplete_changes.parentKeys = /*parentKeys*/ ctx[5];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				autocomplete_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			autocomplete.$set(autocomplete_changes);
		},
		i(local) {
			if (current) return;
			transition_in(autocomplete.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(autocomplete.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(autocomplete, detaching);
		}
	};
}

// (51:8) {#if schema[parentKeys].type === "id"}
function create_if_block_8(ctx) {
	let id;
	let updating_field;
	let current;

	function id_field_binding(value) {
		/*id_field_binding*/ ctx[17](value);
	}

	let id_props = {};

	if (/*field*/ ctx[0] !== void 0) {
		id_props.field = /*field*/ ctx[0];
	}

	id = new ID({ props: id_props });
	binding_callbacks.push(() => bind(id, "field", id_field_binding));

	return {
		c() {
			create_component(id.$$.fragment);
		},
		l(nodes) {
			claim_component(id.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(id, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const id_changes = {};

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				id_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			id.$set(id_changes);
		},
		i(local) {
			if (current) return;
			transition_in(id.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(id.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(id, detaching);
		}
	};
}

// (54:8) {#if schema[parentKeys].type === "text"}
function create_if_block_7(ctx) {
	let text_1;
	let updating_field;
	let current;

	function text_1_field_binding(value) {
		/*text_1_field_binding*/ ctx[18](value);
	}

	let text_1_props = {
		schema: /*schema*/ ctx[6],
		parentKeys: /*parentKeys*/ ctx[5]
	};

	if (/*field*/ ctx[0] !== void 0) {
		text_1_props.field = /*field*/ ctx[0];
	}

	text_1 = new Text({ props: text_1_props });
	binding_callbacks.push(() => bind(text_1, "field", text_1_field_binding));

	return {
		c() {
			create_component(text_1.$$.fragment);
		},
		l(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const text_1_changes = {};
			if (dirty[0] & /*schema*/ 64) text_1_changes.schema = /*schema*/ ctx[6];
			if (dirty[0] & /*parentKeys*/ 32) text_1_changes.parentKeys = /*parentKeys*/ ctx[5];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				text_1_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			text_1.$set(text_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(text_1, detaching);
		}
	};
}

// (57:8) {#if schema[parentKeys].type === "number"}
function create_if_block_6(ctx) {
	let number;
	let updating_field;
	let current;

	function number_field_binding(value) {
		/*number_field_binding*/ ctx[19](value);
	}

	let number_props = {};

	if (/*field*/ ctx[0] !== void 0) {
		number_props.field = /*field*/ ctx[0];
	}

	number = new Number({ props: number_props });
	binding_callbacks.push(() => bind(number, "field", number_field_binding));

	return {
		c() {
			create_component(number.$$.fragment);
		},
		l(nodes) {
			claim_component(number.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(number, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const number_changes = {};

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				number_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			number.$set(number_changes);
		},
		i(local) {
			if (current) return;
			transition_in(number.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(number.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(number, detaching);
		}
	};
}

// (60:8) {#if schema[parentKeys].type === "boolean"}
function create_if_block_5(ctx) {
	let boolean;
	let updating_field;
	let current;

	function boolean_field_binding(value) {
		/*boolean_field_binding*/ ctx[20](value);
	}

	let boolean_props = { label: /*label*/ ctx[4] };

	if (/*field*/ ctx[0] !== void 0) {
		boolean_props.field = /*field*/ ctx[0];
	}

	boolean = new Boolean({ props: boolean_props });
	binding_callbacks.push(() => bind(boolean, "field", boolean_field_binding));

	return {
		c() {
			create_component(boolean.$$.fragment);
		},
		l(nodes) {
			claim_component(boolean.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(boolean, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const boolean_changes = {};
			if (dirty[0] & /*label*/ 16) boolean_changes.label = /*label*/ ctx[4];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				boolean_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			boolean.$set(boolean_changes);
		},
		i(local) {
			if (current) return;
			transition_in(boolean.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(boolean.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(boolean, detaching);
		}
	};
}

// (63:8) {#if schema[parentKeys].type === "date"}
function create_if_block_4(ctx) {
	let date;
	let updating_field;
	let current;

	function date_field_binding(value) {
		/*date_field_binding*/ ctx[21](value);
	}

	let date_props = {};

	if (/*field*/ ctx[0] !== void 0) {
		date_props.field = /*field*/ ctx[0];
	}

	date = new Date({ props: date_props });
	binding_callbacks.push(() => bind(date, "field", date_field_binding));

	return {
		c() {
			create_component(date.$$.fragment);
		},
		l(nodes) {
			claim_component(date.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(date, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const date_changes = {};

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				date_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			date.$set(date_changes);
		},
		i(local) {
			if (current) return;
			transition_in(date.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(date.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(date, detaching);
		}
	};
}

// (66:8) {#if schema[parentKeys].type === "time"}
function create_if_block_3(ctx) {
	let time;
	let updating_field;
	let current;

	function time_field_binding(value) {
		/*time_field_binding*/ ctx[22](value);
	}

	let time_props = {};

	if (/*field*/ ctx[0] !== void 0) {
		time_props.field = /*field*/ ctx[0];
	}

	time = new Time({ props: time_props });
	binding_callbacks.push(() => bind(time, "field", time_field_binding));

	return {
		c() {
			create_component(time.$$.fragment);
		},
		l(nodes) {
			claim_component(time.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(time, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const time_changes = {};

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				time_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			time.$set(time_changes);
		},
		i(local) {
			if (current) return;
			transition_in(time.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(time.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(time, detaching);
		}
	};
}

// (69:8) {#if schema[parentKeys].type === "media"}
function create_if_block_2(ctx) {
	let media;
	let updating_field;
	let updating_showMediaModal;
	let updating_changingMedia;
	let updating_localMediaList;
	let current;

	function media_field_binding(value) {
		/*media_field_binding*/ ctx[23](value);
	}

	function media_showMediaModal_binding(value) {
		/*media_showMediaModal_binding*/ ctx[24](value);
	}

	function media_changingMedia_binding(value) {
		/*media_changingMedia_binding*/ ctx[25](value);
	}

	function media_localMediaList_binding(value) {
		/*media_localMediaList_binding*/ ctx[26](value);
	}

	let media_props = {};

	if (/*field*/ ctx[0] !== void 0) {
		media_props.field = /*field*/ ctx[0];
	}

	if (/*showMediaModal*/ ctx[1] !== void 0) {
		media_props.showMediaModal = /*showMediaModal*/ ctx[1];
	}

	if (/*changingMedia*/ ctx[2] !== void 0) {
		media_props.changingMedia = /*changingMedia*/ ctx[2];
	}

	if (/*localMediaList*/ ctx[3] !== void 0) {
		media_props.localMediaList = /*localMediaList*/ ctx[3];
	}

	media = new Media({ props: media_props });
	binding_callbacks.push(() => bind(media, "field", media_field_binding));
	binding_callbacks.push(() => bind(media, "showMediaModal", media_showMediaModal_binding));
	binding_callbacks.push(() => bind(media, "changingMedia", media_changingMedia_binding));
	binding_callbacks.push(() => bind(media, "localMediaList", media_localMediaList_binding));

	return {
		c() {
			create_component(media.$$.fragment);
		},
		l(nodes) {
			claim_component(media.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(media, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const media_changes = {};

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				media_changes.field = /*field*/ ctx[0];
				add_flush_callback(() => updating_field = false);
			}

			if (!updating_showMediaModal && dirty[0] & /*showMediaModal*/ 2) {
				updating_showMediaModal = true;
				media_changes.showMediaModal = /*showMediaModal*/ ctx[1];
				add_flush_callback(() => updating_showMediaModal = false);
			}

			if (!updating_changingMedia && dirty[0] & /*changingMedia*/ 4) {
				updating_changingMedia = true;
				media_changes.changingMedia = /*changingMedia*/ ctx[2];
				add_flush_callback(() => updating_changingMedia = false);
			}

			if (!updating_localMediaList && dirty[0] & /*localMediaList*/ 8) {
				updating_localMediaList = true;
				media_changes.localMediaList = /*localMediaList*/ ctx[3];
				add_flush_callback(() => updating_localMediaList = false);
			}

			media.$set(media_changes);
		},
		i(local) {
			if (current) return;
			transition_in(media.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(media.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(media, detaching);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*label*/ ctx[4] !== "plenti_salt" && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[4] !== "plenti_salt") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*label*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { field } = $$props,
		{ label } = $$props,
		{ showMediaModal } = $$props,
		{ changingMedia } = $$props,
		{ localMediaList } = $$props,
		{ parentKeys } = $$props,
		{ schema } = $$props;

	let { shadowContent = false } = $$props;

	function component_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function component_showMediaModal_binding(value) {
		showMediaModal = value;
		$$invalidate(1, showMediaModal);
	}

	function component_changingMedia_binding(value) {
		changingMedia = value;
		$$invalidate(2, changingMedia);
	}

	function component_localMediaList_binding(value) {
		localMediaList = value;
		$$invalidate(3, localMediaList);
	}

	function checkbox_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function radio_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function select_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function wysiwyg_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function autocomplete_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function id_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function text_1_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function number_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function boolean_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function date_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function time_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function media_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function media_showMediaModal_binding(value) {
		showMediaModal = value;
		$$invalidate(1, showMediaModal);
	}

	function media_changingMedia_binding(value) {
		changingMedia = value;
		$$invalidate(2, changingMedia);
	}

	function media_localMediaList_binding(value) {
		localMediaList = value;
		$$invalidate(3, localMediaList);
	}

	function number_field_binding_1(value) {
		field = value;
		$$invalidate(0, field);
	}

	function date_field_binding_1(value) {
		field = value;
		$$invalidate(0, field);
	}

	function time_field_binding_1(value) {
		field = value;
		$$invalidate(0, field);
	}

	function media_field_binding_1(value) {
		field = value;
		$$invalidate(0, field);
	}

	function media_showMediaModal_binding_1(value) {
		showMediaModal = value;
		$$invalidate(1, showMediaModal);
	}

	function media_changingMedia_binding_1(value) {
		changingMedia = value;
		$$invalidate(2, changingMedia);
	}

	function media_localMediaList_binding_1(value) {
		localMediaList = value;
		$$invalidate(3, localMediaList);
	}

	function text_1_field_binding_1(value) {
		field = value;
		$$invalidate(0, field);
	}

	function boolean_field_binding_1(value) {
		field = value;
		$$invalidate(0, field);
	}

	function component_field_binding_1(value) {
		field = value;
		$$invalidate(0, field);
	}

	function component_showMediaModal_binding_1(value) {
		showMediaModal = value;
		$$invalidate(1, showMediaModal);
	}

	function component_changingMedia_binding_1(value) {
		changingMedia = value;
		$$invalidate(2, changingMedia);
	}

	function component_localMediaList_binding_1(value) {
		localMediaList = value;
		$$invalidate(3, localMediaList);
	}

	function fieldset_field_binding(value) {
		field = value;
		$$invalidate(0, field);
	}

	function fieldset_showMediaModal_binding(value) {
		showMediaModal = value;
		$$invalidate(1, showMediaModal);
	}

	function fieldset_changingMedia_binding(value) {
		changingMedia = value;
		$$invalidate(2, changingMedia);
	}

	function fieldset_localMediaList_binding(value) {
		localMediaList = value;
		$$invalidate(3, localMediaList);
	}

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
		if ("label" in $$props) $$invalidate(4, label = $$props.label);
		if ("showMediaModal" in $$props) $$invalidate(1, showMediaModal = $$props.showMediaModal);
		if ("changingMedia" in $$props) $$invalidate(2, changingMedia = $$props.changingMedia);
		if ("localMediaList" in $$props) $$invalidate(3, localMediaList = $$props.localMediaList);
		if ("parentKeys" in $$props) $$invalidate(5, parentKeys = $$props.parentKeys);
		if ("schema" in $$props) $$invalidate(6, schema = $$props.schema);
		if ("shadowContent" in $$props) $$invalidate(7, shadowContent = $$props.shadowContent);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*shadowContent, label, field*/ 145) {
			$: if (shadowContent !== false) {
				$$invalidate(7, shadowContent[label] = field, shadowContent);
			}
		}
	};

	return [
		field,
		showMediaModal,
		changingMedia,
		localMediaList,
		label,
		parentKeys,
		schema,
		shadowContent,
		component_field_binding,
		component_showMediaModal_binding,
		component_changingMedia_binding,
		component_localMediaList_binding,
		checkbox_field_binding,
		radio_field_binding,
		select_field_binding,
		wysiwyg_field_binding,
		autocomplete_field_binding,
		id_field_binding,
		text_1_field_binding,
		number_field_binding,
		boolean_field_binding,
		date_field_binding,
		time_field_binding,
		media_field_binding,
		media_showMediaModal_binding,
		media_changingMedia_binding,
		media_localMediaList_binding,
		number_field_binding_1,
		date_field_binding_1,
		time_field_binding_1,
		media_field_binding_1,
		media_showMediaModal_binding_1,
		media_changingMedia_binding_1,
		media_localMediaList_binding_1,
		text_1_field_binding_1,
		boolean_field_binding_1,
		component_field_binding_1,
		component_showMediaModal_binding_1,
		component_changingMedia_binding_1,
		component_localMediaList_binding_1,
		fieldset_field_binding,
		fieldset_showMediaModal_binding,
		fieldset_changingMedia_binding,
		fieldset_localMediaList_binding
	];
}

class Component_1 extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				field: 0,
				label: 4,
				showMediaModal: 1,
				changingMedia: 2,
				localMediaList: 3,
				parentKeys: 5,
				schema: 6,
				shadowContent: 7
			},
			[-1, -1]
		);
	}
}

export default Component_1;