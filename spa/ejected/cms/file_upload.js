/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	bubble,
	check_outros,
	children,
	claim_component,
	claim_element,
	claim_space,
	claim_text,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	prevent_default,
	run_all,
	safe_not_equal,
	space,
	svg_element,
	text,
	transition_in,
	transition_out
} from '../../web_modules/svelte/internal/index.mjs';

import MediaFilters from './media_filters.js';
import MediaGrid from './media_grid.js';
import ButtonWrapper from './button_wrapper.js';
import Button from './button.js';

function create_else_block_1(ctx) {
	let div5;
	let div2;
	let div0;
	let svg;
	let path0;
	let path1;
	let polyline;
	let line;
	let t0;
	let div1;
	let t1;
	let div2_class_value;
	let t2;
	let div3;
	let t3;
	let t4;
	let div4;
	let label;
	let input;
	let input_multiple_value;
	let t5;
	let span;
	let mounted;
	let dispose;

	return {
		c() {
			div5 = element("div");
			div2 = element("div");
			div0 = element("div");
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			t0 = space();
			div1 = element("div");
			t1 = text("Drag a file here to upload");
			t2 = space();
			div3 = element("div");
			t3 = text("Or");
			t4 = space();
			div4 = element("div");
			label = element("label");
			input = element("input");
			t5 = space();
			span = element("span");
			this.h();
		},
		l(nodes) {
			div5 = claim_element(nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div2 = claim_element(div5_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			svg = claim_element(
				div0_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			polyline = claim_element(svg_nodes, "polyline", { points: true }, 1);
			children(polyline).forEach(detach);
			line = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line).forEach(detach);
			svg_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t0 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t1 = claim_text(div1_nodes, "Drag a file here to upload");
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t2 = claim_space(div5_nodes);
			div3 = claim_element(div5_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			t3 = claim_text(div3_nodes, "Or");
			div3_nodes.forEach(detach);
			t4 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			label = claim_element(div4_nodes, "LABEL", { class: true });
			var label_nodes = children(label);

			input = claim_element(label_nodes, "INPUT", {
				type: true,
				"aria-label": true,
				class: true
			});

			t5 = claim_space(label_nodes);
			span = claim_element(label_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			label_nodes.forEach(detach);
			div4_nodes.forEach(detach);
			div5_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M7 18a4.6 4.4 0 0 1 0 -9a5 4.5 0 0 1 11 2h1a3.5 3.5 0 0 1 0 7h-1");
			attr(polyline, "points", "9 15 12 12 15 15");
			attr(line, "x1", "12");
			attr(line, "y1", "12");
			attr(line, "x2", "12");
			attr(line, "y2", "21");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-cloud-upload");
			attr(svg, "width", "44");
			attr(svg, "height", "44");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "1.5");
			attr(svg, "stroke", "#2c3e50");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(div0, "class", "drop-icon");
			attr(div1, "class", "drop-text");
			attr(div2, "class", div2_class_value = "drop" + (/*drag*/ ctx[7] ? " active" : "") + " svelte-6x59kg");
			attr(div3, "class", "or svelte-6x59kg");
			attr(input, "type", "file");
			input.multiple = input_multiple_value = /*changingAsset*/ ctx[2] ? false : true;
			attr(input, "aria-label", "File browser");
			attr(input, "class", "svelte-6x59kg");
			attr(span, "class", "file-custom svelte-6x59kg");
			attr(label, "class", "file svelte-6x59kg");
			attr(div4, "class", "choose");
			attr(div5, "class", "upload-widgets svelte-6x59kg");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div2);
			append(div2, div0);
			append(div0, svg);
			append(svg, path0);
			append(svg, path1);
			append(svg, polyline);
			append(svg, line);
			append(div2, t0);
			append(div2, div1);
			append(div1, t1);
			append(div5, t2);
			append(div5, div3);
			append(div3, t3);
			append(div5, t4);
			append(div5, div4);
			append(div4, label);
			append(label, input);
			append(label, t5);
			append(label, span);

			if (!mounted) {
				dispose = [
					listen(div2, "dragenter", /*toggleDrag*/ ctx[10]),
					listen(div2, "dragleave", /*toggleDrag*/ ctx[10]),
					listen(div2, "drop", prevent_default(/*drop_handler*/ ctx[22])),
					listen(div2, "dragover", prevent_default(/*dragover_handler*/ ctx[15])),
					listen(div4, "change", /*change_handler*/ ctx[23])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*drag*/ 128 && div2_class_value !== (div2_class_value = "drop" + (/*drag*/ ctx[7] ? " active" : "") + " svelte-6x59kg")) {
				attr(div2, "class", div2_class_value);
			}

			if (dirty & /*changingAsset*/ 4 && input_multiple_value !== (input_multiple_value = /*changingAsset*/ ctx[2] ? false : true)) {
				input.multiple = input_multiple_value;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div5);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (75:4) {#if localMediaList.length > 0}
function create_if_block(ctx) {
	let mediafilters;
	let updating_assets;
	let updating_enabledFilters;
	let t0;
	let mediagrid;
	let updating_selectedMedia;
	let t1;
	let buttonwrapper;
	let current;

	function mediafilters_assets_binding(value) {
		/*mediafilters_assets_binding*/ ctx[16](value);
	}

	function mediafilters_enabledFilters_binding(value) {
		/*mediafilters_enabledFilters_binding*/ ctx[17](value);
	}

	let mediafilters_props = {
		singleSelect: true,
		changingAsset: /*changingAsset*/ ctx[2]
	};

	if (/*assets*/ ctx[1] !== void 0) {
		mediafilters_props.assets = /*assets*/ ctx[1];
	}

	if (/*enabledFilters*/ ctx[5] !== void 0) {
		mediafilters_props.enabledFilters = /*enabledFilters*/ ctx[5];
	}

	mediafilters = new MediaFilters({ props: mediafilters_props });
	binding_callbacks.push(() => bind(mediafilters, "assets", mediafilters_assets_binding));
	binding_callbacks.push(() => bind(mediafilters, "enabledFilters", mediafilters_enabledFilters_binding));

	function mediagrid_selectedMedia_binding(value) {
		/*mediagrid_selectedMedia_binding*/ ctx[18](value);
	}

	let mediagrid_props = {
		files: /*getThumbnails*/ ctx[13](/*localMediaList*/ ctx[0])
	};

	if (/*selectedMedia*/ ctx[8] !== void 0) {
		mediagrid_props.selectedMedia = /*selectedMedia*/ ctx[8];
	}

	mediagrid = new MediaGrid({ props: mediagrid_props });
	binding_callbacks.push(() => bind(mediagrid, "selectedMedia", mediagrid_selectedMedia_binding));

	buttonwrapper = new ButtonWrapper({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(mediafilters.$$.fragment);
			t0 = space();
			create_component(mediagrid.$$.fragment);
			t1 = space();
			create_component(buttonwrapper.$$.fragment);
		},
		l(nodes) {
			claim_component(mediafilters.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(mediagrid.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(buttonwrapper.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(mediafilters, target, anchor);
			insert(target, t0, anchor);
			mount_component(mediagrid, target, anchor);
			insert(target, t1, anchor);
			mount_component(buttonwrapper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const mediafilters_changes = {};
			if (dirty & /*changingAsset*/ 4) mediafilters_changes.changingAsset = /*changingAsset*/ ctx[2];

			if (!updating_assets && dirty & /*assets*/ 2) {
				updating_assets = true;
				mediafilters_changes.assets = /*assets*/ ctx[1];
				add_flush_callback(() => updating_assets = false);
			}

			if (!updating_enabledFilters && dirty & /*enabledFilters*/ 32) {
				updating_enabledFilters = true;
				mediafilters_changes.enabledFilters = /*enabledFilters*/ ctx[5];
				add_flush_callback(() => updating_enabledFilters = false);
			}

			mediafilters.$set(mediafilters_changes);
			const mediagrid_changes = {};
			if (dirty & /*localMediaList*/ 1) mediagrid_changes.files = /*getThumbnails*/ ctx[13](/*localMediaList*/ ctx[0]);

			if (!updating_selectedMedia && dirty & /*selectedMedia*/ 256) {
				updating_selectedMedia = true;
				mediagrid_changes.selectedMedia = /*selectedMedia*/ ctx[8];
				add_flush_callback(() => updating_selectedMedia = false);
			}

			mediagrid.$set(mediagrid_changes);
			const buttonwrapper_changes = {};

			if (dirty & /*$$scope, selectedMedia, localMediaList, enabledFilters, filePrefix, assetPrefix, changingAsset, showMedia*/ 33554813) {
				buttonwrapper_changes.$$scope = { dirty, ctx };
			}

			buttonwrapper.$set(buttonwrapper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(mediafilters.$$.fragment, local);
			transition_in(mediagrid.$$.fragment, local);
			transition_in(buttonwrapper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(mediafilters.$$.fragment, local);
			transition_out(mediagrid.$$.fragment, local);
			transition_out(buttonwrapper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(mediafilters, detaching);
			if (detaching) detach(t0);
			destroy_component(mediagrid, detaching);
			if (detaching) detach(t1);
			destroy_component(buttonwrapper, detaching);
		}
	};
}

// (100:12) {:else}
function create_else_block(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				buttonText: "Discard all",
				buttonStyle: "secondary"
			}
		});

	button.$on("click", /*click_handler_1*/ ctx[21]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		l(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (94:12) {#if selectedMedia.length > 0}
function create_if_block_1(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				buttonText: "Discard selected",
				buttonStyle: "secondary"
			}
		});

	button.$on("click", /*removeSelectedMedia*/ ctx[12]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		l(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (78:8) <ButtonWrapper>
function create_default_slot(ctx) {
	let button;
	let updating_commitList;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	function button_commitList_binding(value) {
		/*button_commitList_binding*/ ctx[19](value);
	}

	let button_props = {
		buttonText: "Save Media",
		action: "create",
		encoding: "base64"
	};

	if (/*localMediaList*/ ctx[0] !== void 0) {
		button_props.commitList = /*localMediaList*/ ctx[0];
	}

	button = new Button({ props: button_props });
	binding_callbacks.push(() => bind(button, "commitList", button_commitList_binding));
	button.$on("click", /*click_handler*/ ctx[20]);
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*selectedMedia*/ ctx[8].length > 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			create_component(button.$$.fragment);
			t = space();
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			claim_component(button.$$.fragment, nodes);
			t = claim_space(nodes);
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			insert(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (!updating_commitList && dirty & /*localMediaList*/ 1) {
				updating_commitList = true;
				button_changes.commitList = /*localMediaList*/ ctx[0];
				add_flush_callback(() => updating_commitList = false);
			}

			button.$set(button_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
			if (detaching) detach(t);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*localMediaList*/ ctx[0].length > 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if_block.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "upload-wrapper svelte-6x59kg");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { assets } = $$props,
		{ changingAsset } = $$props,
		{ showMedia } = $$props,
		{ localMediaList } = $$props,
		{ assetPrefix } = $$props;

	let enabledFilters = [];

	const createMediaList = file => {
		let reader = new FileReader();
		reader.readAsDataURL(file);

		reader.onload = e => {
			$$invalidate(0, localMediaList = [
				...localMediaList,
				{
					file: assetPrefix + "assets/" + file.name,
					contents: e.target.result
				}
			]);
		};
	};

	const selectFile = files => {
		Array.from(files).forEach(file => {
			createMediaList(file);
		});
	};

	let filePrefix = assetPrefix + "assets/";
	let drag;

	const toggleDrag = () => {
		$$invalidate(7, drag = !drag);
	};

	const dropFile = ev => {
		if (ev.dataTransfer.items) {
			// Use DataTransferItemList interface to access the file(s)
			for (let i = 0; i < ev.dataTransfer.items.length; i++) {
				// If dropped items aren't files, reject them
				if (ev.dataTransfer.items[i].kind === "file") {
					let file = ev.dataTransfer.items[i].getAsFile();
					createMediaList(file);
				}
			}
		}
	};

	let selectedMedia = [];

	const removeSelectedMedia = () => {
		selectedMedia.forEach(file => {
			$$invalidate(0, localMediaList = localMediaList.filter(i => i.contents !== file));
			$$invalidate(8, selectedMedia = []);
		});
	};

	const getThumbnails = mediaList => mediaList.map(i => i.contents);

	const addUploadToLibrary = () => {
		localMediaList.forEach(m => {
			$$invalidate(1, assets = [...assets, m.contents]);
		});
	};

	function dragover_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mediafilters_assets_binding(value) {
		assets = value;
		$$invalidate(1, assets);
	}

	function mediafilters_enabledFilters_binding(value) {
		enabledFilters = value;
		$$invalidate(5, enabledFilters);
	}

	function mediagrid_selectedMedia_binding(value) {
		selectedMedia = value;
		$$invalidate(8, selectedMedia);
	}

	function button_commitList_binding(value) {
		localMediaList = value;
		$$invalidate(0, localMediaList);
	}

	const click_handler = () => {
		addUploadToLibrary();
		$$invalidate(5, enabledFilters = []);
		$$invalidate(6, filePrefix = assetPrefix + "assets/");

		if (changingAsset) {
			$$invalidate(2, changingAsset = localMediaList[0].file);
			$$invalidate(3, showMedia = false);
		}
	};

	const click_handler_1 = () => $$invalidate(0, localMediaList = []);
	const drop_handler = event => dropFile(event);
	const change_handler = event => selectFile(event.target.files);

	$$self.$$set = $$props => {
		if ("assets" in $$props) $$invalidate(1, assets = $$props.assets);
		if ("changingAsset" in $$props) $$invalidate(2, changingAsset = $$props.changingAsset);
		if ("showMedia" in $$props) $$invalidate(3, showMedia = $$props.showMedia);
		if ("localMediaList" in $$props) $$invalidate(0, localMediaList = $$props.localMediaList);
		if ("assetPrefix" in $$props) $$invalidate(4, assetPrefix = $$props.assetPrefix);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*enabledFilters, assetPrefix, localMediaList, filePrefix*/ 113) {
			$: if (enabledFilters) {
				if (enabledFilters.length > 0) {
					// Convert filter array to path
					let filterPath = enabledFilters[0].join("/") + "/";

					let newPrefix = assetPrefix + "assets/" + filterPath;

					localMediaList.forEach(mediaFile => {
						mediaFile.file = mediaFile.file.replace(filePrefix, newPrefix);
					});

					// Set new prefix in case filter is switched and needs to be replaced
					$$invalidate(6, filePrefix = newPrefix);
				}
			}
		}
	};

	return [
		localMediaList,
		assets,
		changingAsset,
		showMedia,
		assetPrefix,
		enabledFilters,
		filePrefix,
		drag,
		selectedMedia,
		selectFile,
		toggleDrag,
		dropFile,
		removeSelectedMedia,
		getThumbnails,
		addUploadToLibrary,
		dragover_handler,
		mediafilters_assets_binding,
		mediafilters_enabledFilters_binding,
		mediagrid_selectedMedia_binding,
		button_commitList_binding,
		click_handler,
		click_handler_1,
		drop_handler,
		change_handler
	];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			assets: 1,
			changingAsset: 2,
			showMedia: 3,
			localMediaList: 0,
			assetPrefix: 4
		});
	}
}

export default Component;