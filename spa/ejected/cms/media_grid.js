/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	append,
	attr,
	children,
	claim_element,
	claim_space,
	claim_text,
	destroy_each,
	detach,
	element,
	init,
	insert,
	is_function,
	listen,
	noop,
	safe_not_equal,
	set_data,
	space,
	svg_element,
	text
} from '../../web_modules/svelte/internal/index.mjs';

import { onMount } from '../../web_modules/svelte/index.mjs';
import { isImage, isDoc } from './assets_checker.js';

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (38:36) 
function create_if_block_2(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true, class: true });
			this.h();
		},
		h() {
			if (img.src !== (img_src_value = /*file*/ ctx[5])) attr(img, "src", img_src_value);
			attr(img, "class", "svelte-l4dsqj");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*files*/ 2 && img.src !== (img_src_value = /*file*/ ctx[5])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (36:12) {#if isDoc(file)}
function create_if_block_1(ctx) {
	let embed;
	let embed_src_value;

	return {
		c() {
			embed = element("embed");
			this.h();
		},
		l(nodes) {
			embed = claim_element(nodes, "EMBED", { src: true, type: true, class: true });
			this.h();
		},
		h() {
			if (embed.src !== (embed_src_value = /*file*/ ctx[5])) attr(embed, "src", embed_src_value);
			attr(embed, "type", "application/pdf");
			attr(embed, "class", "svelte-l4dsqj");
		},
		m(target, anchor) {
			insert(target, embed, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*files*/ 2 && embed.src !== (embed_src_value = /*file*/ ctx[5])) {
				attr(embed, "src", embed_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(embed);
		}
	};
}

// (42:12) {#if selectedMedia.includes(file)}
function create_if_block(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M5 12l5 5l10 -10");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-check svelte-l4dsqj");
			attr(svg, "width", "65");
			attr(svg, "height", "65");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "2.5");
			attr(svg, "stroke", "#1c7fc7");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (34:4) {#each files as file}
function create_each_block(ctx) {
	let div1;
	let show_if_1;
	let show_if_2;
	let t0;
	let div0;
	let t1_value = /*file*/ ctx[5].split("/").pop() + "";
	let t1;
	let t2;
	let show_if = /*selectedMedia*/ ctx[0].includes(/*file*/ ctx[5]);
	let t3;
	let div1_class_value;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (show_if_1 == null || dirty & /*files*/ 2) show_if_1 = !!isDoc(/*file*/ ctx[5]);
		if (show_if_1) return create_if_block_1;
		if (show_if_2 == null || dirty & /*files*/ 2) show_if_2 = !!isImage(/*file*/ ctx[5]);
		if (show_if_2) return create_if_block_2;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block0 = current_block_type && current_block_type(ctx);
	let if_block1 = show_if && create_if_block(ctx);

	return {
		c() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div0 = element("div");
			t1 = text(t1_value);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (if_block0) if_block0.l(div1_nodes);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t1 = claim_text(div0_nodes, t1_value);
			div0_nodes.forEach(detach);
			t2 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			t3 = claim_space(div1_nodes);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "filename svelte-l4dsqj");

			attr(div1, "class", div1_class_value = "media" + (/*selectedMedia*/ ctx[0].includes(/*file*/ ctx[5])
			? " selected"
			: "") + " svelte-l4dsqj");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t0);
			append(div1, div0);
			append(div0, t1);
			append(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append(div1, t3);

			if (!mounted) {
				dispose = listen(div1, "click", function () {
					if (is_function(/*selectMedia*/ ctx[2](/*file*/ ctx[5]))) /*selectMedia*/ ctx[2](/*file*/ ctx[5]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div1, t0);
				}
			}

			if (dirty & /*files*/ 2 && t1_value !== (t1_value = /*file*/ ctx[5].split("/").pop() + "")) set_data(t1, t1_value);
			if (dirty & /*selectedMedia, files*/ 3) show_if = /*selectedMedia*/ ctx[0].includes(/*file*/ ctx[5]);

			if (show_if) {
				if (if_block1) {
					
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(div1, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*selectedMedia, files*/ 3 && div1_class_value !== (div1_class_value = "media" + (/*selectedMedia*/ ctx[0].includes(/*file*/ ctx[5])
			? " selected"
			: "") + " svelte-l4dsqj")) {
				attr(div1, "class", div1_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div1);

			if (if_block0) {
				if_block0.d();
			}

			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let div;
	let each_value = /*files*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "media-grid svelte-l4dsqj");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*selectedMedia, files, selectMedia, isDoc, isImage*/ 7) {
				each_value = /*files*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { files } = $$props, { changingAsset } = $$props, { showMedia } = $$props;
	let { selectedMedia = [] } = $$props;

	onMount(async () => {
		focus();

		window.addEventListener("blur", () => {
			let embeds = document.querySelectorAll("embed");

			embeds.forEach(embed => {
				if (document.activeElement === embed) {
					selectMedia(embed.attributes.src.nodeValue);
				}
			});

			window.parent.focus();
		});
	});

	const selectMedia = file => {
		if (changingAsset !== "") {
			$$invalidate(3, changingAsset = file);
			$$invalidate(4, showMedia = false);
		}

		if (selectedMedia.includes(file)) {
			$$invalidate(0, selectedMedia = selectedMedia.filter(m => m !== file));
		} else {
			$$invalidate(0, selectedMedia = [...selectedMedia, file]);
		}
	};

	$$self.$$set = $$props => {
		if ("files" in $$props) $$invalidate(1, files = $$props.files);
		if ("changingAsset" in $$props) $$invalidate(3, changingAsset = $$props.changingAsset);
		if ("showMedia" in $$props) $$invalidate(4, showMedia = $$props.showMedia);
		if ("selectedMedia" in $$props) $$invalidate(0, selectedMedia = $$props.selectedMedia);
	};

	return [selectedMedia, files, selectMedia, changingAsset, showMedia];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			files: 1,
			changingAsset: 3,
			showMedia: 4,
			selectedMedia: 0
		});
	}
}

export default Component;