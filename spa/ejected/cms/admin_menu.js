/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_flush_callback,
	add_render_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	bubble,
	check_outros,
	children,
	claim_component,
	claim_element,
	claim_space,
	claim_text,
	create_bidirectional_transition,
	create_component,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	is_function,
	listen,
	mount_component,
	noop,
	null_to_empty,
	prevent_default,
	run_all,
	safe_not_equal,
	space,
	stop_propagation,
	subscribe,
	svg_element,
	text,
	transition_in,
	transition_out
} from '../../web_modules/svelte/internal/index.mjs';

import JSONEditor from './json_editor.js';
import MediaBrowser from './media_browser.js';
import FileUpload from './file_upload.js';
import VisualEditor from './visual_editor.js';
import AddContent from './add_content.js';
import allAssets from './assets.js';
import { env } from '../env.js';

function create_else_block_2(ctx) {
	let svg;
	let path0;
	let path1;
	let line;
	let t;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			line = svg_element("line");
			t = text("\n    Edit");
			this.h();
		},
		l(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			line = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line).forEach(detach);
			svg_nodes.forEach(detach);
			t = claim_text(nodes, "\n    Edit");
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4");
			attr(line, "x1", "13.5");
			attr(line, "y1", "6.5");
			attr(line, "x2", "17.5");
			attr(line, "y2", "10.5");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-pencil svelte-w9j5o0");
			attr(svg, "width", "30");
			attr(svg, "height", "30");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke", "#2c3e50");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, line);
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (detaching) detach(t);
		}
	};
}

// (59:4) {#if showEditor}
function create_if_block_5(ctx) {
	let svg;
	let path0;
	let circle;
	let path1;
	let t;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			circle = svg_element("circle");
			path1 = svg_element("path");
			t = text("\n    View");
			this.h();
		},
		l(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			circle = claim_element(svg_nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			svg_nodes.forEach(detach);
			t = claim_text(nodes, "\n    View");
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(circle, "cx", "12");
			attr(circle, "cy", "12");
			attr(circle, "r", "2");
			attr(path1, "d", "M22 12c-2.667 4.667 -6 7 -10 7s-7.333 -2.333 -10 -7c2.667 -4.667 6 -7 10 -7s7.333 2.333 10 7");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-eye svelte-w9j5o0");
			attr(svg, "width", "30");
			attr(svg, "height", "30");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke", "#2c3e50");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, circle);
			append(svg, path1);
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (detaching) detach(t);
		}
	};
}

// (105:0) {#if showMedia}
function create_if_block_3(ctx) {
	let div5;
	let div0;
	let svg0;
	let path0;
	let line0;
	let line1;
	let t0;
	let div4;
	let div3;
	let div1;
	let svg1;
	let path1;
	let path2;
	let polyline;
	let line2;
	let t1;
	let span0;
	let t2;
	let div1_class_value;
	let t3;
	let div2;
	let svg2;
	let path3;
	let rect0;
	let rect1;
	let rect2;
	let rect3;
	let t4;
	let span1;
	let t5;
	let div2_class_value;
	let t6;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_4, create_else_block_1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*activeMedia*/ ctx[5] === "library") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div5 = element("div");
			div0 = element("div");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			t0 = space();
			div4 = element("div");
			div3 = element("div");
			div1 = element("div");
			svg1 = svg_element("svg");
			path1 = svg_element("path");
			path2 = svg_element("path");
			polyline = svg_element("polyline");
			line2 = svg_element("line");
			t1 = space();
			span0 = element("span");
			t2 = text("Upload");
			t3 = space();
			div2 = element("div");
			svg2 = svg_element("svg");
			path3 = svg_element("path");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			t4 = space();
			span1 = element("span");
			t5 = text("Library");
			t6 = space();
			if_block.c();
			this.h();
		},
		l(nodes) {
			div5 = claim_element(nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div0 = claim_element(div5_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			svg0 = claim_element(
				div0_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg0_nodes = children(svg0);
			path0 = claim_element(svg0_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			line0 = claim_element(svg0_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach);
			line1 = claim_element(svg0_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach);
			svg0_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t0 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);

			svg1 = claim_element(
				div1_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg1_nodes = children(svg1);
			path1 = claim_element(svg1_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path1).forEach(detach);
			path2 = claim_element(svg1_nodes, "path", { d: true }, 1);
			children(path2).forEach(detach);
			polyline = claim_element(svg1_nodes, "polyline", { points: true }, 1);
			children(polyline).forEach(detach);
			line2 = claim_element(svg1_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line2).forEach(detach);
			svg1_nodes.forEach(detach);
			t1 = claim_space(div1_nodes);
			span0 = claim_element(div1_nodes, "SPAN", {});
			var span0_nodes = children(span0);
			t2 = claim_text(span0_nodes, "Upload");
			span0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t3 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);

			svg2 = claim_element(
				div2_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg2_nodes = children(svg2);
			path3 = claim_element(svg2_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path3).forEach(detach);

			rect0 = claim_element(
				svg2_nodes,
				"rect",
				{
					x: true,
					y: true,
					width: true,
					height: true,
					rx: true
				},
				1
			);

			children(rect0).forEach(detach);

			rect1 = claim_element(
				svg2_nodes,
				"rect",
				{
					x: true,
					y: true,
					width: true,
					height: true,
					rx: true
				},
				1
			);

			children(rect1).forEach(detach);

			rect2 = claim_element(
				svg2_nodes,
				"rect",
				{
					x: true,
					y: true,
					width: true,
					height: true,
					rx: true
				},
				1
			);

			children(rect2).forEach(detach);

			rect3 = claim_element(
				svg2_nodes,
				"rect",
				{
					x: true,
					y: true,
					width: true,
					height: true,
					rx: true
				},
				1
			);

			children(rect3).forEach(detach);
			svg2_nodes.forEach(detach);
			t4 = claim_space(div2_nodes);
			span1 = claim_element(div2_nodes, "SPAN", {});
			var span1_nodes = children(span1);
			t5 = claim_text(span1_nodes, "Library");
			span1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			t6 = claim_space(div4_nodes);
			if_block.l(div4_nodes);
			div4_nodes.forEach(detach);
			div5_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(line0, "x1", "18");
			attr(line0, "y1", "6");
			attr(line0, "x2", "6");
			attr(line0, "y2", "18");
			attr(line1, "x1", "6");
			attr(line1, "y1", "6");
			attr(line1, "x2", "18");
			attr(line1, "y2", "18");
			attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg0, "class", "icon icon-tabler icon-tabler-x svelte-w9j5o0");
			attr(svg0, "width", "35");
			attr(svg0, "height", "35");
			attr(svg0, "viewBox", "5 5 14 14");
			attr(svg0, "stroke-width", "1.5");
			attr(svg0, "stroke", "white");
			attr(svg0, "fill", "none");
			attr(svg0, "stroke-linecap", "round");
			attr(svg0, "stroke-linejoin", "round");
			attr(div0, "class", "modal-close svelte-w9j5o0");
			attr(path1, "stroke", "none");
			attr(path1, "d", "M0 0h24v24H0z");
			attr(path1, "fill", "none");
			attr(path2, "d", "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2");
			attr(polyline, "points", "7 9 12 4 17 9");
			attr(line2, "x1", "12");
			attr(line2, "y1", "4");
			attr(line2, "x2", "12");
			attr(line2, "y2", "16");
			attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg1, "class", "icon icon-tabler icon-tabler-upload svelte-w9j5o0");
			attr(svg1, "width", "30");
			attr(svg1, "height", "30");
			attr(svg1, "viewBox", "0 0 24 24");
			attr(svg1, "stroke-width", "1.5");
			attr(svg1, "stroke", "#2c3e50");
			attr(svg1, "fill", "none");
			attr(svg1, "stroke-linecap", "round");
			attr(svg1, "stroke-linejoin", "round");
			attr(div1, "class", div1_class_value = "selector " + (/*activeMedia*/ ctx[5] === "upload" ? "active" : "") + " svelte-w9j5o0");
			attr(path3, "stroke", "none");
			attr(path3, "d", "M0 0h24v24H0z");
			attr(path3, "fill", "none");
			attr(rect0, "x", "4");
			attr(rect0, "y", "4");
			attr(rect0, "width", "6");
			attr(rect0, "height", "6");
			attr(rect0, "rx", "1");
			attr(rect1, "x", "14");
			attr(rect1, "y", "4");
			attr(rect1, "width", "6");
			attr(rect1, "height", "6");
			attr(rect1, "rx", "1");
			attr(rect2, "x", "4");
			attr(rect2, "y", "14");
			attr(rect2, "width", "6");
			attr(rect2, "height", "6");
			attr(rect2, "rx", "1");
			attr(rect3, "x", "14");
			attr(rect3, "y", "14");
			attr(rect3, "width", "6");
			attr(rect3, "height", "6");
			attr(rect3, "rx", "1");
			attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg2, "class", "icon icon-tabler icon-tabler-layout-grid svelte-w9j5o0");
			attr(svg2, "width", "30");
			attr(svg2, "height", "30");
			attr(svg2, "viewBox", "0 0 24 24");
			attr(svg2, "stroke-width", "1.5");
			attr(svg2, "stroke", "#2c3e50");
			attr(svg2, "fill", "none");
			attr(svg2, "stroke-linecap", "round");
			attr(svg2, "stroke-linejoin", "round");
			attr(div2, "class", div2_class_value = "selector " + (/*activeMedia*/ ctx[5] === "library" ? "active" : "") + " svelte-w9j5o0");
			attr(div3, "class", "selectors svelte-w9j5o0");
			attr(div4, "class", "modal svelte-w9j5o0");
			attr(div5, "class", "modal-wrapper svelte-w9j5o0");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div0);
			append(div0, svg0);
			append(svg0, path0);
			append(svg0, line0);
			append(svg0, line1);
			append(div5, t0);
			append(div5, div4);
			append(div4, div3);
			append(div3, div1);
			append(div1, svg1);
			append(svg1, path1);
			append(svg1, path2);
			append(svg1, polyline);
			append(svg1, line2);
			append(div1, t1);
			append(div1, span0);
			append(span0, t2);
			append(div3, t3);
			append(div3, div2);
			append(div2, svg2);
			append(svg2, path3);
			append(svg2, rect0);
			append(svg2, rect1);
			append(svg2, rect2);
			append(svg2, rect3);
			append(div2, t4);
			append(div2, span1);
			append(span1, t5);
			append(div4, t6);
			if_blocks[current_block_type_index].m(div4, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "click", /*click_handler_3*/ ctx[21]),
					listen(div2, "click", /*click_handler_4*/ ctx[22]),
					listen(div4, "click", stop_propagation(/*click_handler*/ ctx[19])),
					listen(div5, "click", /*toggleMedia*/ ctx[13])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*activeMedia*/ 32 && div1_class_value !== (div1_class_value = "selector " + (/*activeMedia*/ ctx[5] === "upload" ? "active" : "") + " svelte-w9j5o0")) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty[0] & /*activeMedia*/ 32 && div2_class_value !== (div2_class_value = "selector " + (/*activeMedia*/ ctx[5] === "library" ? "active" : "") + " svelte-w9j5o0")) {
				attr(div2, "class", div2_class_value);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div4, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (138:6) {:else}
function create_else_block_1(ctx) {
	let fileupload;
	let updating_assets;
	let updating_changingAsset;
	let updating_showMedia;
	let updating_localMediaList;
	let current;

	function fileupload_assets_binding(value) {
		/*fileupload_assets_binding*/ ctx[26](value);
	}

	function fileupload_changingAsset_binding(value) {
		/*fileupload_changingAsset_binding*/ ctx[27](value);
	}

	function fileupload_showMedia_binding(value) {
		/*fileupload_showMedia_binding*/ ctx[28](value);
	}

	function fileupload_localMediaList_binding(value) {
		/*fileupload_localMediaList_binding*/ ctx[29](value);
	}

	let fileupload_props = { assetPrefix: /*assetPrefix*/ ctx[12] };

	if (/*assets*/ ctx[3] !== void 0) {
		fileupload_props.assets = /*assets*/ ctx[3];
	}

	if (/*changingAsset*/ ctx[9] !== void 0) {
		fileupload_props.changingAsset = /*changingAsset*/ ctx[9];
	}

	if (/*showMedia*/ ctx[4] !== void 0) {
		fileupload_props.showMedia = /*showMedia*/ ctx[4];
	}

	if (/*localMediaList*/ ctx[10] !== void 0) {
		fileupload_props.localMediaList = /*localMediaList*/ ctx[10];
	}

	fileupload = new FileUpload({ props: fileupload_props });
	binding_callbacks.push(() => bind(fileupload, "assets", fileupload_assets_binding));
	binding_callbacks.push(() => bind(fileupload, "changingAsset", fileupload_changingAsset_binding));
	binding_callbacks.push(() => bind(fileupload, "showMedia", fileupload_showMedia_binding));
	binding_callbacks.push(() => bind(fileupload, "localMediaList", fileupload_localMediaList_binding));

	return {
		c() {
			create_component(fileupload.$$.fragment);
		},
		l(nodes) {
			claim_component(fileupload.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(fileupload, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const fileupload_changes = {};

			if (!updating_assets && dirty[0] & /*assets*/ 8) {
				updating_assets = true;
				fileupload_changes.assets = /*assets*/ ctx[3];
				add_flush_callback(() => updating_assets = false);
			}

			if (!updating_changingAsset && dirty[0] & /*changingAsset*/ 512) {
				updating_changingAsset = true;
				fileupload_changes.changingAsset = /*changingAsset*/ ctx[9];
				add_flush_callback(() => updating_changingAsset = false);
			}

			if (!updating_showMedia && dirty[0] & /*showMedia*/ 16) {
				updating_showMedia = true;
				fileupload_changes.showMedia = /*showMedia*/ ctx[4];
				add_flush_callback(() => updating_showMedia = false);
			}

			if (!updating_localMediaList && dirty[0] & /*localMediaList*/ 1024) {
				updating_localMediaList = true;
				fileupload_changes.localMediaList = /*localMediaList*/ ctx[10];
				add_flush_callback(() => updating_localMediaList = false);
			}

			fileupload.$set(fileupload_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fileupload.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fileupload.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(fileupload, detaching);
		}
	};
}

// (136:6) {#if activeMedia === 'library'}
function create_if_block_4(ctx) {
	let mediabrowser;
	let updating_assets;
	let updating_changingAsset;
	let updating_showMedia;
	let current;

	function mediabrowser_assets_binding(value) {
		/*mediabrowser_assets_binding*/ ctx[23](value);
	}

	function mediabrowser_changingAsset_binding(value) {
		/*mediabrowser_changingAsset_binding*/ ctx[24](value);
	}

	function mediabrowser_showMedia_binding(value) {
		/*mediabrowser_showMedia_binding*/ ctx[25](value);
	}

	let mediabrowser_props = {};

	if (/*assets*/ ctx[3] !== void 0) {
		mediabrowser_props.assets = /*assets*/ ctx[3];
	}

	if (/*changingAsset*/ ctx[9] !== void 0) {
		mediabrowser_props.changingAsset = /*changingAsset*/ ctx[9];
	}

	if (/*showMedia*/ ctx[4] !== void 0) {
		mediabrowser_props.showMedia = /*showMedia*/ ctx[4];
	}

	mediabrowser = new MediaBrowser({ props: mediabrowser_props });
	binding_callbacks.push(() => bind(mediabrowser, "assets", mediabrowser_assets_binding));
	binding_callbacks.push(() => bind(mediabrowser, "changingAsset", mediabrowser_changingAsset_binding));
	binding_callbacks.push(() => bind(mediabrowser, "showMedia", mediabrowser_showMedia_binding));

	return {
		c() {
			create_component(mediabrowser.$$.fragment);
		},
		l(nodes) {
			claim_component(mediabrowser.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(mediabrowser, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const mediabrowser_changes = {};

			if (!updating_assets && dirty[0] & /*assets*/ 8) {
				updating_assets = true;
				mediabrowser_changes.assets = /*assets*/ ctx[3];
				add_flush_callback(() => updating_assets = false);
			}

			if (!updating_changingAsset && dirty[0] & /*changingAsset*/ 512) {
				updating_changingAsset = true;
				mediabrowser_changes.changingAsset = /*changingAsset*/ ctx[9];
				add_flush_callback(() => updating_changingAsset = false);
			}

			if (!updating_showMedia && dirty[0] & /*showMedia*/ 16) {
				updating_showMedia = true;
				mediabrowser_changes.showMedia = /*showMedia*/ ctx[4];
				add_flush_callback(() => updating_showMedia = false);
			}

			mediabrowser.$set(mediabrowser_changes);
		},
		i(local) {
			if (current) return;
			transition_in(mediabrowser.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(mediabrowser.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(mediabrowser, detaching);
		}
	};
}

// (145:0) {#if showAdd}
function create_if_block_2(ctx) {
	let div2;
	let div0;
	let svg;
	let path;
	let line0;
	let line1;
	let t;
	let div1;
	let addcontent;
	let updating_showAdd;
	let updating_showEditor;
	let current;
	let mounted;
	let dispose;

	function addcontent_showAdd_binding(value) {
		/*addcontent_showAdd_binding*/ ctx[30](value);
	}

	function addcontent_showEditor_binding(value) {
		/*addcontent_showEditor_binding*/ ctx[31](value);
	}

	let addcontent_props = {};

	if (/*showAdd*/ ctx[8] !== void 0) {
		addcontent_props.showAdd = /*showAdd*/ ctx[8];
	}

	if (/*showEditor*/ ctx[6] !== void 0) {
		addcontent_props.showEditor = /*showEditor*/ ctx[6];
	}

	addcontent = new AddContent({ props: addcontent_props });
	binding_callbacks.push(() => bind(addcontent, "showAdd", addcontent_showAdd_binding));
	binding_callbacks.push(() => bind(addcontent, "showEditor", addcontent_showEditor_binding));

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			t = space();
			div1 = element("div");
			create_component(addcontent.$$.fragment);
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			svg = claim_element(
				div0_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path).forEach(detach);
			line0 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach);
			line1 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach);
			svg_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(addcontent.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path, "stroke", "none");
			attr(path, "d", "M0 0h24v24H0z");
			attr(path, "fill", "none");
			attr(line0, "x1", "18");
			attr(line0, "y1", "6");
			attr(line0, "x2", "6");
			attr(line0, "y2", "18");
			attr(line1, "x1", "6");
			attr(line1, "y1", "6");
			attr(line1, "x2", "18");
			attr(line1, "y2", "18");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-x svelte-w9j5o0");
			attr(svg, "width", "35");
			attr(svg, "height", "35");
			attr(svg, "viewBox", "5 5 14 14");
			attr(svg, "stroke-width", "1.5");
			attr(svg, "stroke", "white");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(div0, "class", "modal-close svelte-w9j5o0");
			attr(div1, "class", "modal small svelte-w9j5o0");
			attr(div2, "class", "modal-wrapper svelte-w9j5o0");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div0, svg);
			append(svg, path);
			append(svg, line0);
			append(svg, line1);
			append(div2, t);
			append(div2, div1);
			mount_component(addcontent, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "click", stop_propagation(/*click_handler_1*/ ctx[18])),
					listen(div2, "click", /*click_handler_5*/ ctx[32])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			const addcontent_changes = {};

			if (!updating_showAdd && dirty[0] & /*showAdd*/ 256) {
				updating_showAdd = true;
				addcontent_changes.showAdd = /*showAdd*/ ctx[8];
				add_flush_callback(() => updating_showAdd = false);
			}

			if (!updating_showEditor && dirty[0] & /*showEditor*/ 64) {
				updating_showEditor = true;
				addcontent_changes.showEditor = /*showEditor*/ ctx[6];
				add_flush_callback(() => updating_showEditor = false);
			}

			addcontent.$set(addcontent_changes);
		},
		i(local) {
			if (current) return;
			transition_in(addcontent.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addcontent.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_component(addcontent);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (162:0) {#if showEditor}
function create_if_block(ctx) {
	let div3;
	let div2;
	let div0;
	let svg0;
	let path0;
	let rect;
	let line0;
	let line1;
	let t0;
	let span0;
	let t1;
	let div0_class_value;
	let t2;
	let div1;
	let svg1;
	let path1;
	let path2;
	let path3;
	let t3;
	let span1;
	let t4;
	let div1_class_value;
	let t5;
	let current_block_type_index;
	let if_block;
	let div3_class_value;
	let div3_transition;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*activeEditor*/ ctx[7] === "code") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			t0 = space();
			span0 = element("span");
			t1 = text("Visual");
			t2 = space();
			div1 = element("div");
			svg1 = svg_element("svg");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			t3 = space();
			span1 = element("span");
			t4 = text("Code");
			t5 = space();
			if_block.c();
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			svg0 = claim_element(
				div0_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg0_nodes = children(svg0);
			path0 = claim_element(svg0_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);

			rect = claim_element(
				svg0_nodes,
				"rect",
				{
					x: true,
					y: true,
					width: true,
					height: true,
					rx: true
				},
				1
			);

			children(rect).forEach(detach);
			line0 = claim_element(svg0_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach);
			line1 = claim_element(svg0_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach);
			svg0_nodes.forEach(detach);
			t0 = claim_space(div0_nodes);
			span0 = claim_element(div0_nodes, "SPAN", {});
			var span0_nodes = children(span0);
			t1 = claim_text(span0_nodes, "Visual");
			span0_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t2 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);

			svg1 = claim_element(
				div1_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg1_nodes = children(svg1);
			path1 = claim_element(svg1_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path1).forEach(detach);
			path2 = claim_element(svg1_nodes, "path", { d: true }, 1);
			children(path2).forEach(detach);
			path3 = claim_element(svg1_nodes, "path", { d: true }, 1);
			children(path3).forEach(detach);
			svg1_nodes.forEach(detach);
			t3 = claim_space(div1_nodes);
			span1 = claim_element(div1_nodes, "SPAN", {});
			var span1_nodes = children(span1);
			t4 = claim_text(span1_nodes, "Code");
			span1_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t5 = claim_space(div3_nodes);
			if_block.l(div3_nodes);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(rect, "x", "4");
			attr(rect, "y", "4");
			attr(rect, "width", "16");
			attr(rect, "height", "16");
			attr(rect, "rx", "2");
			attr(line0, "x1", "4");
			attr(line0, "y1", "10");
			attr(line0, "x2", "20");
			attr(line0, "y2", "10");
			attr(line1, "x1", "10");
			attr(line1, "y1", "4");
			attr(line1, "x2", "10");
			attr(line1, "y2", "20");
			attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg0, "class", "icon icon-tabler icon-tabler-table svelte-w9j5o0");
			attr(svg0, "width", "30");
			attr(svg0, "height", "30");
			attr(svg0, "viewBox", "0 0 24 24");
			attr(svg0, "stroke-width", "1.5");
			attr(svg0, "stroke", "#2c3e50");
			attr(svg0, "fill", "none");
			attr(svg0, "stroke-linecap", "round");
			attr(svg0, "stroke-linejoin", "round");
			attr(div0, "class", div0_class_value = "selector " + (/*activeEditor*/ ctx[7] === "visual" ? "active" : "") + " svelte-w9j5o0");
			attr(path1, "stroke", "none");
			attr(path1, "d", "M0 0h24v24H0z");
			attr(path1, "fill", "none");
			attr(path2, "d", "M7 4a2 2 0 0 0 -2 2v3a2 3 0 0 1 -2 3a2 3 0 0 1 2 3v3a2 2 0 0 0 2 2");
			attr(path3, "d", "M17 4a2 2 0 0 1 2 2v3a2 3 0 0 0 2 3a2 3 0 0 0 -2 3v3a2 2 0 0 1 -2 2");
			attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg1, "class", "icon icon-tabler icon-tabler-braces svelte-w9j5o0");
			attr(svg1, "width", "30");
			attr(svg1, "height", "30");
			attr(svg1, "viewBox", "0 0 24 24");
			attr(svg1, "stroke-width", "1.5");
			attr(svg1, "stroke", "#2c3e50");
			attr(svg1, "fill", "none");
			attr(svg1, "stroke-linecap", "round");
			attr(svg1, "stroke-linejoin", "round");
			attr(div1, "class", div1_class_value = "selector " + (/*activeEditor*/ ctx[7] === "code" ? "active" : "") + " svelte-w9j5o0");
			attr(div2, "class", "selectors svelte-w9j5o0");
			attr(div3, "class", div3_class_value = "" + (null_to_empty(/*showEditor*/ ctx[6] ? "sidenav" : "") + " svelte-w9j5o0"));
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div2);
			append(div2, div0);
			append(div0, svg0);
			append(svg0, path0);
			append(svg0, rect);
			append(svg0, line0);
			append(svg0, line1);
			append(div0, t0);
			append(div0, span0);
			append(span0, t1);
			append(div2, t2);
			append(div2, div1);
			append(div1, svg1);
			append(svg1, path1);
			append(svg1, path2);
			append(svg1, path3);
			append(div1, t3);
			append(div1, span1);
			append(span1, t4);
			append(div3, t5);
			if_blocks[current_block_type_index].m(div3, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*click_handler_6*/ ctx[33]),
					listen(div1, "click", /*click_handler_7*/ ctx[34])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*activeEditor*/ 128 && div0_class_value !== (div0_class_value = "selector " + (/*activeEditor*/ ctx[7] === "visual" ? "active" : "") + " svelte-w9j5o0")) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty[0] & /*activeEditor*/ 128 && div1_class_value !== (div1_class_value = "selector " + (/*activeEditor*/ ctx[7] === "code" ? "active" : "") + " svelte-w9j5o0")) {
				attr(div1, "class", div1_class_value);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div3, null);
			}

			if (!current || dirty[0] & /*showEditor*/ 64 && div3_class_value !== (div3_class_value = "" + (null_to_empty(/*showEditor*/ ctx[6] ? "sidenav" : "") + " svelte-w9j5o0"))) {
				attr(div3, "class", div3_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);

			if (local) {
				add_render_callback(() => {
					if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*horizontalSlide*/ ctx[17], {}, true);
					div3_transition.run(1);
				});
			}

			current = true;
		},
		o(local) {
			transition_out(if_block);

			if (local) {
				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*horizontalSlide*/ ctx[17], {}, false);
				div3_transition.run(0);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			if_blocks[current_block_type_index].d();
			if (detaching && div3_transition) div3_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (185:4) {:else}
function create_else_block(ctx) {
	let visualeditor;
	let updating_content;
	let updating_showMedia;
	let updating_changingAsset;
	let updating_localMediaList;
	let updating_shadowContent;
	let current;

	function visualeditor_content_binding(value) {
		/*visualeditor_content_binding*/ ctx[36](value);
	}

	function visualeditor_showMedia_binding(value) {
		/*visualeditor_showMedia_binding*/ ctx[37](value);
	}

	function visualeditor_changingAsset_binding(value) {
		/*visualeditor_changingAsset_binding*/ ctx[38](value);
	}

	function visualeditor_localMediaList_binding(value) {
		/*visualeditor_localMediaList_binding*/ ctx[39](value);
	}

	function visualeditor_shadowContent_binding(value) {
		/*visualeditor_shadowContent_binding*/ ctx[40](value);
	}

	let visualeditor_props = {};

	if (/*content*/ ctx[0] !== void 0) {
		visualeditor_props.content = /*content*/ ctx[0];
	}

	if (/*showMedia*/ ctx[4] !== void 0) {
		visualeditor_props.showMedia = /*showMedia*/ ctx[4];
	}

	if (/*changingAsset*/ ctx[9] !== void 0) {
		visualeditor_props.changingAsset = /*changingAsset*/ ctx[9];
	}

	if (/*localMediaList*/ ctx[10] !== void 0) {
		visualeditor_props.localMediaList = /*localMediaList*/ ctx[10];
	}

	if (/*shadowContent*/ ctx[1] !== void 0) {
		visualeditor_props.shadowContent = /*shadowContent*/ ctx[1];
	}

	visualeditor = new VisualEditor({ props: visualeditor_props });
	binding_callbacks.push(() => bind(visualeditor, "content", visualeditor_content_binding));
	binding_callbacks.push(() => bind(visualeditor, "showMedia", visualeditor_showMedia_binding));
	binding_callbacks.push(() => bind(visualeditor, "changingAsset", visualeditor_changingAsset_binding));
	binding_callbacks.push(() => bind(visualeditor, "localMediaList", visualeditor_localMediaList_binding));
	binding_callbacks.push(() => bind(visualeditor, "shadowContent", visualeditor_shadowContent_binding));

	return {
		c() {
			create_component(visualeditor.$$.fragment);
		},
		l(nodes) {
			claim_component(visualeditor.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(visualeditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const visualeditor_changes = {};

			if (!updating_content && dirty[0] & /*content*/ 1) {
				updating_content = true;
				visualeditor_changes.content = /*content*/ ctx[0];
				add_flush_callback(() => updating_content = false);
			}

			if (!updating_showMedia && dirty[0] & /*showMedia*/ 16) {
				updating_showMedia = true;
				visualeditor_changes.showMedia = /*showMedia*/ ctx[4];
				add_flush_callback(() => updating_showMedia = false);
			}

			if (!updating_changingAsset && dirty[0] & /*changingAsset*/ 512) {
				updating_changingAsset = true;
				visualeditor_changes.changingAsset = /*changingAsset*/ ctx[9];
				add_flush_callback(() => updating_changingAsset = false);
			}

			if (!updating_localMediaList && dirty[0] & /*localMediaList*/ 1024) {
				updating_localMediaList = true;
				visualeditor_changes.localMediaList = /*localMediaList*/ ctx[10];
				add_flush_callback(() => updating_localMediaList = false);
			}

			if (!updating_shadowContent && dirty[0] & /*shadowContent*/ 2) {
				updating_shadowContent = true;
				visualeditor_changes.shadowContent = /*shadowContent*/ ctx[1];
				add_flush_callback(() => updating_shadowContent = false);
			}

			visualeditor.$set(visualeditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(visualeditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(visualeditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(visualeditor, detaching);
		}
	};
}

// (183:4) {#if activeEditor === 'code'}
function create_if_block_1(ctx) {
	let jsoneditor;
	let updating_content;
	let current;

	function jsoneditor_content_binding(value) {
		/*jsoneditor_content_binding*/ ctx[35](value);
	}

	let jsoneditor_props = {};

	if (/*content*/ ctx[0] !== void 0) {
		jsoneditor_props.content = /*content*/ ctx[0];
	}

	jsoneditor = new JSONEditor({ props: jsoneditor_props });
	binding_callbacks.push(() => bind(jsoneditor, "content", jsoneditor_content_binding));

	return {
		c() {
			create_component(jsoneditor.$$.fragment);
		},
		l(nodes) {
			claim_component(jsoneditor.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(jsoneditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const jsoneditor_changes = {};

			if (!updating_content && dirty[0] & /*content*/ 1) {
				updating_content = true;
				jsoneditor_changes.content = /*content*/ ctx[0];
				add_flush_callback(() => updating_content = false);
			}

			jsoneditor.$set(jsoneditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(jsoneditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(jsoneditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(jsoneditor, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div0;
	let t0;
	let nav;
	let a0;
	let svg0;
	let path0;
	let polyline;
	let path1;
	let t1;
	let a0_href_value;
	let t2;
	let a1;
	let a1_class_value;
	let t3;
	let span;
	let t4;
	let a2;
	let svg1;
	let path2;
	let circle;
	let line0;
	let line1;
	let t5;
	let t6;
	let a3;
	let svg2;
	let path3;
	let line2;
	let rect;
	let path4;
	let path5;
	let t7;
	let t8;
	let a4;
	let svg3;
	let path6;
	let path7;
	let path8;
	let t9;
	let t10;
	let t11;
	let t12;
	let div1;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*showEditor*/ ctx[6]) return create_if_block_5;
		return create_else_block_2;
	}

	let current_block_type = select_block_type(ctx, [-1, -1]);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*showMedia*/ ctx[4] && create_if_block_3(ctx);
	let if_block2 = /*showAdd*/ ctx[8] && create_if_block_2(ctx);
	let if_block3 = /*showEditor*/ ctx[6] && create_if_block(ctx);

	return {
		c() {
			div0 = element("div");
			t0 = space();
			nav = element("nav");
			a0 = element("a");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			polyline = svg_element("polyline");
			path1 = svg_element("path");
			t1 = text("\n    Home");
			t2 = space();
			a1 = element("a");
			if_block0.c();
			t3 = space();
			span = element("span");
			t4 = space();
			a2 = element("a");
			svg1 = svg_element("svg");
			path2 = svg_element("path");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			t5 = text("\n    Add");
			t6 = space();
			a3 = element("a");
			svg2 = svg_element("svg");
			path3 = svg_element("path");
			line2 = svg_element("line");
			rect = svg_element("rect");
			path4 = svg_element("path");
			path5 = svg_element("path");
			t7 = text("\n    Media");
			t8 = space();
			a4 = element("a");
			svg3 = svg_element("svg");
			path6 = svg_element("path");
			path7 = svg_element("path");
			path8 = svg_element("path");
			t9 = text("\n    Logout");
			t10 = space();
			if (if_block1) if_block1.c();
			t11 = space();
			if (if_block2) if_block2.c();
			t12 = space();
			div1 = element("div");
			if (if_block3) if_block3.c();
			this.h();
		},
		l(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			children(div0).forEach(detach);
			t0 = claim_space(nodes);
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			a0 = claim_element(nav_nodes, "A", { href: true, class: true });
			var a0_nodes = children(a0);

			svg0 = claim_element(
				a0_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg0_nodes = children(svg0);
			path0 = claim_element(svg0_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			polyline = claim_element(svg0_nodes, "polyline", { points: true }, 1);
			children(polyline).forEach(detach);
			path1 = claim_element(svg0_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			svg0_nodes.forEach(detach);
			t1 = claim_text(a0_nodes, "\n    Home");
			a0_nodes.forEach(detach);
			t2 = claim_space(nav_nodes);
			a1 = claim_element(nav_nodes, "A", { href: true, class: true });
			var a1_nodes = children(a1);
			if_block0.l(a1_nodes);
			a1_nodes.forEach(detach);
			t3 = claim_space(nav_nodes);
			span = claim_element(nav_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			t4 = claim_space(nav_nodes);
			a2 = claim_element(nav_nodes, "A", { href: true, class: true });
			var a2_nodes = children(a2);

			svg1 = claim_element(
				a2_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg1_nodes = children(svg1);
			path2 = claim_element(svg1_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path2).forEach(detach);
			circle = claim_element(svg1_nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle).forEach(detach);
			line0 = claim_element(svg1_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach);
			line1 = claim_element(svg1_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach);
			svg1_nodes.forEach(detach);
			t5 = claim_text(a2_nodes, "\n    Add");
			a2_nodes.forEach(detach);
			t6 = claim_space(nav_nodes);
			a3 = claim_element(nav_nodes, "A", { href: true, class: true });
			var a3_nodes = children(a3);

			svg2 = claim_element(
				a3_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg2_nodes = children(svg2);
			path3 = claim_element(svg2_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path3).forEach(detach);
			line2 = claim_element(svg2_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line2).forEach(detach);

			rect = claim_element(
				svg2_nodes,
				"rect",
				{
					x: true,
					y: true,
					width: true,
					height: true,
					rx: true
				},
				1
			);

			children(rect).forEach(detach);
			path4 = claim_element(svg2_nodes, "path", { d: true }, 1);
			children(path4).forEach(detach);
			path5 = claim_element(svg2_nodes, "path", { d: true }, 1);
			children(path5).forEach(detach);
			svg2_nodes.forEach(detach);
			t7 = claim_text(a3_nodes, "\n    Media");
			a3_nodes.forEach(detach);
			t8 = claim_space(nav_nodes);
			a4 = claim_element(nav_nodes, "A", { href: true, class: true });
			var a4_nodes = children(a4);

			svg3 = claim_element(
				a4_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg3_nodes = children(svg3);
			path6 = claim_element(svg3_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path6).forEach(detach);
			path7 = claim_element(svg3_nodes, "path", { d: true }, 1);
			children(path7).forEach(detach);
			path8 = claim_element(svg3_nodes, "path", { d: true }, 1);
			children(path8).forEach(detach);
			svg3_nodes.forEach(detach);
			t9 = claim_text(a4_nodes, "\n    Logout");
			a4_nodes.forEach(detach);
			nav_nodes.forEach(detach);
			t10 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t11 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			t12 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (if_block3) if_block3.l(div1_nodes);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "spacer svelte-w9j5o0");
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(polyline, "points", "5 12 3 12 12 3 21 12 19 12");
			attr(path1, "d", "M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7");
			attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg0, "class", "icon icon-tabler icon-tabler-home-2 svelte-w9j5o0");
			attr(svg0, "width", "30");
			attr(svg0, "height", "30");
			attr(svg0, "viewBox", "0 0 24 24");
			attr(svg0, "stroke-width", "2");
			attr(svg0, "stroke", "#2c3e50");
			attr(svg0, "fill", "none");
			attr(svg0, "stroke-linecap", "round");
			attr(svg0, "stroke-linejoin", "round");
			attr(a0, "href", a0_href_value = env.baseurl ? "." : "/");
			attr(a0, "class", "home svelte-w9j5o0");
			attr(a1, "href", ".");
			attr(a1, "class", a1_class_value = "" + (null_to_empty(/*showEditor*/ ctx[6] ? "view" : "edit") + " svelte-w9j5o0"));
			attr(span, "class", "gap svelte-w9j5o0");
			attr(path2, "stroke", "none");
			attr(path2, "d", "M0 0h24v24H0z");
			attr(path2, "fill", "none");
			attr(circle, "cx", "12");
			attr(circle, "cy", "12");
			attr(circle, "r", "9");
			attr(line0, "x1", "9");
			attr(line0, "y1", "12");
			attr(line0, "x2", "15");
			attr(line0, "y2", "12");
			attr(line1, "x1", "12");
			attr(line1, "y1", "9");
			attr(line1, "x2", "12");
			attr(line1, "y2", "15");
			attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg1, "class", "icon icon-tabler icon-tabler-circle-plus svelte-w9j5o0");
			attr(svg1, "width", "30");
			attr(svg1, "height", "30");
			attr(svg1, "viewBox", "0 0 24 24");
			attr(svg1, "stroke-width", "2");
			attr(svg1, "stroke", "#2c3e50");
			attr(svg1, "fill", "none");
			attr(svg1, "stroke-linecap", "round");
			attr(svg1, "stroke-linejoin", "round");
			attr(a2, "href", ".");
			attr(a2, "class", "add svelte-w9j5o0");
			attr(path3, "stroke", "none");
			attr(path3, "d", "M0 0h24v24H0z");
			attr(path3, "fill", "none");
			attr(line2, "x1", "15");
			attr(line2, "y1", "8");
			attr(line2, "x2", "15.01");
			attr(line2, "y2", "8");
			attr(rect, "x", "4");
			attr(rect, "y", "4");
			attr(rect, "width", "16");
			attr(rect, "height", "16");
			attr(rect, "rx", "3");
			attr(path4, "d", "M4 15l4 -4a3 5 0 0 1 3 0l5 5");
			attr(path5, "d", "M14 14l1 -1a3 5 0 0 1 3 0l2 2");
			attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg2, "class", "icon icon-tabler icon-tabler-photo svelte-w9j5o0");
			attr(svg2, "width", "30");
			attr(svg2, "height", "30");
			attr(svg2, "viewBox", "0 0 24 24");
			attr(svg2, "stroke-width", "2");
			attr(svg2, "stroke", "#2c3e50");
			attr(svg2, "fill", "none");
			attr(svg2, "stroke-linecap", "round");
			attr(svg2, "stroke-linejoin", "round");
			attr(a3, "href", ".");
			attr(a3, "class", "media svelte-w9j5o0");
			attr(path6, "stroke", "none");
			attr(path6, "d", "M0 0h24v24H0z");
			attr(path6, "fill", "none");
			attr(path7, "d", "M14 8v-2a2 2 0 0 0 -2 -2h-7a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2 -2v-2");
			attr(path8, "d", "M7 12h14l-3 -3m0 6l3 -3");
			attr(svg3, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg3, "class", "icon icon-tabler icon-tabler-logout svelte-w9j5o0");
			attr(svg3, "width", "30");
			attr(svg3, "height", "30");
			attr(svg3, "viewBox", "0 0 24 24");
			attr(svg3, "stroke-width", "2");
			attr(svg3, "stroke", "#2c3e50");
			attr(svg3, "fill", "none");
			attr(svg3, "stroke-linecap", "round");
			attr(svg3, "stroke-linejoin", "round");
			attr(a4, "href", ".");
			attr(a4, "class", "logout svelte-w9j5o0");
			attr(nav, "class", "svelte-w9j5o0");
			attr(div1, "class", div1_class_value = "" + (null_to_empty(/*showEditor*/ ctx[6] ? "sidenav-wrapper" : "") + " svelte-w9j5o0"));
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			insert(target, t0, anchor);
			insert(target, nav, anchor);
			append(nav, a0);
			append(a0, svg0);
			append(svg0, path0);
			append(svg0, polyline);
			append(svg0, path1);
			append(a0, t1);
			append(nav, t2);
			append(nav, a1);
			if_block0.m(a1, null);
			append(nav, t3);
			append(nav, span);
			append(nav, t4);
			append(nav, a2);
			append(a2, svg1);
			append(svg1, path2);
			append(svg1, circle);
			append(svg1, line0);
			append(svg1, line1);
			append(a2, t5);
			append(nav, t6);
			append(nav, a3);
			append(a3, svg2);
			append(svg2, path3);
			append(svg2, line2);
			append(svg2, rect);
			append(svg2, path4);
			append(svg2, path5);
			append(a3, t7);
			append(nav, t8);
			append(nav, a4);
			append(a4, svg3);
			append(svg3, path6);
			append(svg3, path7);
			append(svg3, path8);
			append(a4, t9);
			insert(target, t10, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t11, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t12, anchor);
			insert(target, div1, anchor);
			if (if_block3) if_block3.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(a1, "click", prevent_default(/*toggleEditor*/ ctx[15])),
					listen(a2, "click", prevent_default(/*click_handler_2*/ ctx[20])),
					listen(a3, "click", prevent_default(/*toggleMedia*/ ctx[13])),
					listen(a4, "click", prevent_default(function () {
						if (is_function(/*$user*/ ctx[11].logout)) /*$user*/ ctx[11].logout.apply(this, arguments);
					}))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(a1, null);
				}
			}

			if (!current || dirty[0] & /*showEditor*/ 64 && a1_class_value !== (a1_class_value = "" + (null_to_empty(/*showEditor*/ ctx[6] ? "view" : "edit") + " svelte-w9j5o0"))) {
				attr(a1, "class", a1_class_value);
			}

			if (/*showMedia*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*showMedia*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t11.parentNode, t11);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*showAdd*/ ctx[8]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*showAdd*/ 256) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(t12.parentNode, t12);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*showEditor*/ ctx[6]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*showEditor*/ 64) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div1, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*showEditor*/ 64 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*showEditor*/ ctx[6] ? "sidenav-wrapper" : "") + " svelte-w9j5o0"))) {
				attr(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t0);
			if (detaching) detach(nav);
			if_block0.d();
			if (detaching) detach(t10);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t11);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(t12);
			if (detaching) detach(div1);
			if (if_block3) if_block3.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $user,
		$$unsubscribe_user = noop,
		$$subscribe_user = () => ($$unsubscribe_user(), $$unsubscribe_user = subscribe(user, $$value => $$invalidate(11, $user = $$value)), user);

	$$self.$$.on_destroy.push(() => $$unsubscribe_user());
	let { user } = $$props, { content } = $$props, { shadowContent } = $$props;
	$$subscribe_user();
	let assetPrefix = env.baseurl ? "" : "/";
	let assets = allAssets.map(asset => assetPrefix + asset);
	let showMedia = false;

	const toggleMedia = () => {
		$$invalidate(4, showMedia = !showMedia);
		$$invalidate(9, changingAsset = "");
	};

	let activeMedia = "upload";

	const setActiveMedia = selected => {
		$$invalidate(5, activeMedia = selected);
	};

	let showEditor = false;

	const toggleEditor = () => {
		$$invalidate(6, showEditor = !showEditor);
	};

	let activeEditor = "visual";

	const setActiveEditor = selected => {
		$$invalidate(7, activeEditor = selected);
	};

	let showAdd = false;

	const horizontalSlide = () => {
		return {
			delay: 0,
			duration: 100,
			css: t => "width: " + t * 500 + "px;"
		};
	};

	let changingAsset = "";
	let localMediaList = [];

	function click_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler_2 = () => {
		$$invalidate(8, showAdd = true);
	};

	const click_handler_3 = () => setActiveMedia("upload");
	const click_handler_4 = () => setActiveMedia("library");

	function mediabrowser_assets_binding(value) {
		assets = value;
		$$invalidate(3, assets);
	}

	function mediabrowser_changingAsset_binding(value) {
		changingAsset = value;
		$$invalidate(9, changingAsset);
	}

	function mediabrowser_showMedia_binding(value) {
		showMedia = value;
		$$invalidate(4, showMedia);
	}

	function fileupload_assets_binding(value) {
		assets = value;
		$$invalidate(3, assets);
	}

	function fileupload_changingAsset_binding(value) {
		changingAsset = value;
		$$invalidate(9, changingAsset);
	}

	function fileupload_showMedia_binding(value) {
		showMedia = value;
		$$invalidate(4, showMedia);
	}

	function fileupload_localMediaList_binding(value) {
		localMediaList = value;
		$$invalidate(10, localMediaList);
	}

	function addcontent_showAdd_binding(value) {
		showAdd = value;
		$$invalidate(8, showAdd);
	}

	function addcontent_showEditor_binding(value) {
		showEditor = value;
		$$invalidate(6, showEditor);
	}

	const click_handler_5 = () => {
		$$invalidate(8, showAdd = false);
	};

	const click_handler_6 = () => setActiveEditor("visual");
	const click_handler_7 = () => setActiveEditor("code");

	function jsoneditor_content_binding(value) {
		content = value;
		$$invalidate(0, content);
	}

	function visualeditor_content_binding(value) {
		content = value;
		$$invalidate(0, content);
	}

	function visualeditor_showMedia_binding(value) {
		showMedia = value;
		$$invalidate(4, showMedia);
	}

	function visualeditor_changingAsset_binding(value) {
		changingAsset = value;
		$$invalidate(9, changingAsset);
	}

	function visualeditor_localMediaList_binding(value) {
		localMediaList = value;
		$$invalidate(10, localMediaList);
	}

	function visualeditor_shadowContent_binding(value) {
		shadowContent = value;
		$$invalidate(1, shadowContent);
	}

	$$self.$$set = $$props => {
		if ("user" in $$props) $$subscribe_user($$invalidate(2, user = $$props.user));
		if ("content" in $$props) $$invalidate(0, content = $$props.content);
		if ("shadowContent" in $$props) $$invalidate(1, shadowContent = $$props.shadowContent);
	};

	return [
		content,
		shadowContent,
		user,
		assets,
		showMedia,
		activeMedia,
		showEditor,
		activeEditor,
		showAdd,
		changingAsset,
		localMediaList,
		$user,
		assetPrefix,
		toggleMedia,
		setActiveMedia,
		toggleEditor,
		setActiveEditor,
		horizontalSlide,
		click_handler_1,
		click_handler,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		mediabrowser_assets_binding,
		mediabrowser_changingAsset_binding,
		mediabrowser_showMedia_binding,
		fileupload_assets_binding,
		fileupload_changingAsset_binding,
		fileupload_showMedia_binding,
		fileupload_localMediaList_binding,
		addcontent_showAdd_binding,
		addcontent_showEditor_binding,
		click_handler_5,
		click_handler_6,
		click_handler_7,
		jsoneditor_content_binding,
		visualeditor_content_binding,
		visualeditor_showMedia_binding,
		visualeditor_changingAsset_binding,
		visualeditor_localMediaList_binding,
		visualeditor_shadowContent_binding
	];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { user: 2, content: 0, shadowContent: 1 }, [-1, -1]);
	}
}

export default Component;