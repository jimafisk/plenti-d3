/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	append,
	attr,
	children,
	claim_element,
	claim_space,
	claim_text,
	destroy_each,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	safe_not_equal,
	set_data,
	space,
	svg_element,
	text
} from '../../web_modules/svelte/internal/index.mjs';

import { isAssetPath } from './assets_checker.js';

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i];
	return child_ctx;
}

// (100:12) {#each filterGroup as filter}
function create_each_block_1(ctx) {
	let button;
	let t_value = /*filter*/ ctx[17] + "";
	let t;
	let button_class_value;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[10](/*filter*/ ctx[17], /*filterGroup*/ ctx[14]);
	}

	return {
		c() {
			button = element("button");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, t_value);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "class", button_class_value = "filter" + (/*filterIsEnabled*/ ctx[3](/*enabledFilters*/ ctx[0], /*getFilterSubGroup*/ ctx[2](/*filter*/ ctx[17], /*filterGroup*/ ctx[14]))
			? " active"
			: "") + " svelte-atj9qf");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*filters*/ 2 && t_value !== (t_value = /*filter*/ ctx[17] + "")) set_data(t, t_value);

			if (dirty & /*enabledFilters, filters*/ 3 && button_class_value !== (button_class_value = "filter" + (/*filterIsEnabled*/ ctx[3](/*enabledFilters*/ ctx[0], /*getFilterSubGroup*/ ctx[2](/*filter*/ ctx[17], /*filterGroup*/ ctx[14]))
			? " active"
			: "") + " svelte-atj9qf")) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (98:4) {#each filters as filterGroup}
function create_each_block(ctx) {
	let div;
	let t;
	let each_value_1 = /*filterGroup*/ ctx[14];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			t = claim_space(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "filter-group svelte-atj9qf");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*filterIsEnabled, enabledFilters, getFilterSubGroup, filters, toggleFilter*/ 31) {
				each_value_1 = /*filterGroup*/ ctx[14];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (106:4) {#if enabledFilters.length > 0}
function create_if_block(ctx) {
	let button;
	let svg;
	let path;
	let line0;
	let line1;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);

			svg = claim_element(
				button_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path).forEach(detach);
			line0 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach);
			line1 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach);
			svg_nodes.forEach(detach);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path, "stroke", "none");
			attr(path, "d", "M0 0h24v24H0z");
			attr(path, "fill", "none");
			attr(line0, "x1", "18");
			attr(line0, "y1", "6");
			attr(line0, "x2", "6");
			attr(line0, "y2", "18");
			attr(line1, "x1", "6");
			attr(line1, "y1", "6");
			attr(line1, "x2", "18");
			attr(line1, "y2", "18");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-x");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "5 5 14 14");
			attr(svg, "stroke-width", "1.5");
			attr(svg, "stroke", "#2c3e50");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(button, "class", "close svelte-atj9qf");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, svg);
			append(svg, path);
			append(svg, line0);
			append(svg, line1);

			if (!mounted) {
				dispose = listen(button, "click", /*clearFilters*/ ctx[5]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let t;
	let each_value = /*filters*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block = /*enabledFilters*/ ctx[0].length > 0 && create_if_block(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach);
			t = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "filters svelte-atj9qf");
			attr(div1, "class", "filters-wrapper svelte-atj9qf");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append(div1, t);
			if (if_block) if_block.m(div1, null);
		},
		p(ctx, [dirty]) {
			if (dirty & /*filters, filterIsEnabled, enabledFilters, getFilterSubGroup, toggleFilter*/ 31) {
				each_value = /*filters*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*enabledFilters*/ ctx[0].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { assets } = $$props, { changingAsset } = $$props;
	let { filters = [] } = $$props;
	let { enabledFilters = [] } = $$props;
	let { filteredAssets = [] } = $$props;
	let { singleSelect = false } = $$props;

	const assetPathToArray = asset => {
		// Create an array of path segments.
		let allFolders = asset.split("/");

		// Get the index right after the assets folder (works with and without baseurl).
		let cut = allFolders.findIndex(i => i === "assets") + 1;

		// Remove "assets" folder and last (filename) elements.
		return allFolders.slice(cut, -1);
	};

	const parentAssetIndex = (asset, filters) => {
		// Return position of filter in filters array,
		// if it's a subpath of current asset (if not found return -1)
		return filters.findIndex(filter => asset.join("").includes(filter.join("")));
	};

	for (const asset of assets) {
		if (isAssetPath(asset)) {
			// Turn asset path into array of subfolders
			let assetFolders = assetPathToArray(asset);

			// Make sure we're not adding empty filters
			if (assetFolders.length > 0) {
				// Get the index of any parent folders that have already been added
				let subfolderIndex = parentAssetIndex(assetFolders, filters);

				// Check if a parent folder was found
				if (subfolderIndex === -1) {
					// No previously added filter is a subpath of this asset path,
					// so add the asset path to filters
					filters = [...filters, assetFolders];
				} else {
					// Parent path has already been added,
					// replace with more complete path containing child folders
					filters[subfolderIndex] = assetFolders;
				}
			}
		}
	}

	const assetMatchesFilter = (asset, filters) => {
		// Compare arrays in exact order by converting to strings
		return filters.find(filter => asset.join("") === filter.join(""));
	};

	const getFilterSubGroup = (filter, filterGroup) => {
		// Get filters position inside full group array
		let filterIndex = filterGroup.findIndex(f => f === filter);

		// Get array from first folder to where this filter was found (cut off nested folders after that)
		let filterSubGroup = filterGroup.slice(0, filterIndex + 1);

		// Return array of filter and parent folders (no children folders)
		return filterSubGroup;
	};

	const filterIsEnabled = (enabledFilters, filterSubGroup) => {
		// Compare exact order of arrays by converting to strings
		return enabledFilters.find(f => f.join("") === filterSubGroup.join(""));
	};

	const toggleFilter = filterSubGroup => {
		if (singleSelect) {
			clearFilters();
		}

		if (filterIsEnabled(enabledFilters, filterSubGroup)) {
			// Remove filter
			$$invalidate(0, enabledFilters = enabledFilters.filter(current => current.join("") !== filterSubGroup.join("")));
		} else {
			// Add filter and force update for enabled filters
			$$invalidate(0, enabledFilters = [...enabledFilters, filterSubGroup]);
		}
	};

	const clearFilters = () => {
		$$invalidate(0, enabledFilters = []);
	};

	if (changingAsset) {
		// Apply filters from current asset when swapping for new asset
		toggleFilter(assetPathToArray(changingAsset));
	}

	const click_handler = (filter, filterGroup) => toggleFilter(getFilterSubGroup(filter, filterGroup));

	$$self.$$set = $$props => {
		if ("assets" in $$props) $$invalidate(7, assets = $$props.assets);
		if ("changingAsset" in $$props) $$invalidate(8, changingAsset = $$props.changingAsset);
		if ("filters" in $$props) $$invalidate(1, filters = $$props.filters);
		if ("enabledFilters" in $$props) $$invalidate(0, enabledFilters = $$props.enabledFilters);
		if ("filteredAssets" in $$props) $$invalidate(6, filteredAssets = $$props.filteredAssets);
		if ("singleSelect" in $$props) $$invalidate(9, singleSelect = $$props.singleSelect);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*assets, enabledFilters*/ 129) {
			// Filter assets
			$: $$invalidate(6, filteredAssets = assets.filter(asset => {
				// Show all assets if no filter is applied, or
				// Show specific asset if it's in the enabled filters
				return !enabledFilters.length || assetMatchesFilter(assetPathToArray(asset), enabledFilters);
			}));
		}
	};

	return [
		enabledFilters,
		filters,
		getFilterSubGroup,
		filterIsEnabled,
		toggleFilter,
		clearFilters,
		filteredAssets,
		assets,
		changingAsset,
		singleSelect,
		click_handler
	];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			assets: 7,
			changingAsset: 8,
			filters: 1,
			enabledFilters: 0,
			filteredAssets: 6,
			singleSelect: 9
		});
	}
}

export default Component;